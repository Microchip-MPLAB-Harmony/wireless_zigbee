<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>PIC32CX-BZ Zigbee API Reference: OFD and ISD usage</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">PIC32CX-BZ Zigbee API Reference</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">OFD and ISD usage </div>  </div>
</div>
<div class="contents">
<div class="textblock"><p>The two drivers: OTAU Flash driver (OFD) and Image Storage driver (ISD) are employed by the OTAU cluster and may be also used to implement custom over-the-air upgrade scheme. An OTAU client uses the API of OFD to write the incoming firmware image in the external flash memory, while the OTAU server uses the ISD API to pass commands from the client to the storage system and to transfer an image from the storage system to the client.</p>
<p>All OFD and ISD API functions are executed asynchronously. One of the arguments is always a callback function, which is called when the procedures started by the invoked function complete.</p>
<p>The source code of the drivers is available to the user and is compiled with the application.</p>
<h2><a class="anchor" id="OFD"></a>
OFD</h2>
<p>The OTAU Flash driver (OFD) provides functions for saving a firmware image in external memory. BitCloud packages support three types of Microchip DataFlash devices as external memory, but the user may also implement any other type of flash memory. External memory is controlled by the MCU through SPI.</p>
<p>External memory may be large enough to include several firmware images. In this case images may be written with different offset from the beginning of the memory; the number of images that may be written to the memory previous to a given image is called <em>image position</em> (so it equals 0 for the first image and 1 for the second image). Image positions are defined by the <a class="el" href="ofd_ext_memory_8h.html#a5cedc1206b8397e1a2cb04289ebac681" title="The number of an image&#39;s position in the external flash.">OFD_Position_t</a> enumeration; <a class="el" href="ofd_ext_memory_8h.html#a5cedc1206b8397e1a2cb04289ebac681aee22ef27dc3a39f95b32a27536357b53" title="The total number of available positions.">OFD_POSITION_MAX</a> defines the number of available positions.</p>
<p>OFD functions must be called in a particular order to achieve correct behavior of the driver:</p>
<ul>
<li>The <a class="el" href="ofd_ext_memory_8h.html#a5ffe24e3890504c4fea3191d456a80f7" title="Opens the serial interface for connection with the external memory and checks memory type...">OFD_Open()</a> function opens the serial interface for communication with the external memory.</li>
</ul>
<ul>
<li>The <a class="el" href="ofd_ext_memory_8h.html#a12770665330f3f6fa951e82df89c5662" title="Erases an image at a given position in the external memory.">OFD_EraseImage()</a> function must be called once the serial interface is opened to erase the image at the specified image position and, thus, to clear this position for a new image. This step is required because of the properties of flash memory which must be always cleared befor writing</li>
</ul>
<ul>
<li>The <a class="el" href="ofd_ext_memory_8h.html#ae4e68cfaace571c27be7cf3c8ee0c016" title="Writes data to the external memory.">OFD_Write()</a> function should be as many times as needed to write parts of a new image to the specified position in the external memory.</li>
</ul>
<ul>
<li>The <a class="el" href="ofd_ext_memory_8h.html#a9bd01d19510a8780cc3e209c43e493e5" title="Flushes data from the internal buffer, checks image&#39;s crc and saves it to the external memory...">OFD_FlushAndCheckCrc()</a> function is called after <a class="el" href="ofd_ext_memory_8h.html#ae4e68cfaace571c27be7cf3c8ee0c016" title="Writes data to the external memory.">OFD_Write()</a> is called for the last time. Since the external memory is saved in full pages, it may happen that after the last invokation of <a class="el" href="ofd_ext_memory_8h.html#ae4e68cfaace571c27be7cf3c8ee0c016" title="Writes data to the external memory.">OFD_Write()</a> a part of the image may not fit into a page and stay stored in the internal buffer. In this case <a class="el" href="ofd_ext_memory_8h.html#a9bd01d19510a8780cc3e209c43e493e5" title="Flushes data from the internal buffer, checks image&#39;s crc and saves it to the external memory...">OFD_FlushAndCheckCrc()</a> writes this last part to the external memory. Then the function checks the image's CRC and also writes it to the external memory.</li>
</ul>
<ul>
<li>Once the new image is saved in the external memory, the <a class="el" href="ofd_ext_memory_8h.html#a8979297ab669f311a19d6301078df5f4" title="Saves the MCU&#39;s current application image and EEPROM to the external memory, checks crc for it and se...">OFD_SwitchToNewImage()</a> function is called to prepare replacement of the current firmware image. The function copies the current image and EEPROM contents to the specified image position in the external memory (it must differ from the image position of the new image) and sets a special command in EEPROM for bootloader. A switch to new image may be then initiated by the hardware reset invoked by the application. On reset, the bootloader will receive control, check the instructions from EEPROM and start replacing the current image with the new one.</li>
</ul>
<ul>
<li>The <a class="el" href="ofd_ext_memory_8h.html#ac6067c5f2ebb87d6b84790ab2f054d63" title="Closes the serial interface opened using OFD_Open()">OFD_Close()</a> function releases the serial interface used for connection with the external memory. The function must be called if the interface is going to be used for other purposes.</li>
</ul>
<h2><a class="anchor" id="ISD"></a>
ISD</h2>
<p>The Image Storage driver (ISD) can be used to send command equivalent to the OTAU cluster commands to the storage system. In fact, in standard OTAU implementation ISD serves as a bridge between the OTAU server and the storage system, with the OTAU server's simply routing command from the OTAU client.</p>
<p>The storage system may be of any kind (another embedded device, PC, web-server etc.) and be connected to the MCU via any interface or protocol. In the provided implementation the OTAU server exchanges data over UART with the PC application, which user may select devices that should be updated, specify the image file and start upgrade process.</p>
<p>The ISD API functions are described below in the order in which they may be called during a typical update procedure. Note that a callback function is called after the response from the storage system is received.</p>
<ul>
<li>The <a class="el" href="isd_image_storage_8h.html#a5e5a6ac6cf4f9891870eedff9a72e97c" title="Opens the serial interface for connection with the image storage.">ISD_Open()</a> function opens the serial interface for communication with the storage system.</li>
</ul>
<ul>
<li>The <a class="el" href="isd_image_storage_8h.html#a7a05cfc8240f091c24d956e5e81514a1" title="Sends a query next image request to the storage system, which should decide whether the request&#39;s iss...">ISD_QueryNextImageReq()</a> function informs the storage system about the specified network device. The device is identified by its addressing information, which may include network address, endpoint, cluster ID and profile ID. The device also provides manufacturer ID (the storage system may possess different firmware for devices from different manufacturers) and the firmware version. The storage system should decide whether the device needs a new firmware image. In case the response indicates that the client device requires a new image, it should start requesting parts of the the image from the server, which can retrieve them, using the <a class="el" href="isd_image_storage_8h.html#a128149b925620aaebf07d32cf81b31d2" title="Sends an image block request to the storage system, in order to retrieve a certain block of data of t...">ISD_ImageBlockReq()</a> function.</li>
</ul>
<ul>
<li>The <a class="el" href="isd_image_storage_8h.html#a128149b925620aaebf07d32cf81b31d2" title="Sends an image block request to the storage system, in order to retrieve a certain block of data of t...">ISD_ImageBlockReq()</a> function retrieves the block (specified by the offset from the beginning of the image) of an image for the specified device from the storage system.</li>
</ul>
<ul>
<li>The <a class="el" href="isd_image_storage_8h.html#afdfe331e964aa4e5d482e84ca670783c" title="Sends an upgrade end request to the storage system, notifying it that all blocks have been received...">ISD_UpgradeEndReq()</a> function informs the storage system that the specified clien has uploaded all blocks of the image. In response, the storage system sends the confirmation and the time span, which should pass on the client before it should replace the current image with the uploaded one.</li>
</ul>
<ul>
<li>The <a class="el" href="isd_image_storage_8h.html#a60dd9264ce39d8e26ea4b434db07eff4" title="Closes the serial interface opened using ISD_Open()">ISD_Close()</a> function releases the serial interface used for connection with the storage system. The function must be called if the interface is going to be used for other purposes.</li>
</ul>
<p>The first argument of <a class="el" href="isd_image_storage_8h.html#a7a05cfc8240f091c24d956e5e81514a1" title="Sends a query next image request to the storage system, which should decide whether the request&#39;s iss...">ISD_QueryNextImageReq()</a>, <a class="el" href="isd_image_storage_8h.html#a128149b925620aaebf07d32cf81b31d2" title="Sends an image block request to the storage system, in order to retrieve a certain block of data of t...">ISD_ImageBlockReq()</a> and <a class="el" href="isd_image_storage_8h.html#afdfe331e964aa4e5d482e84ca670783c" title="Sends an upgrade end request to the storage system, notifying it that all blocks have been received...">ISD_UpgradeEndReq()</a> functions specifies the addressing infromation, which should be used by the storage system to identify the client device. In standard implementation the OTAU cluster fills this field with the addressing information extracted from the frame with the corresponding ZCL command. In this case the addressing information includes the endpoint, cluster ID and profile ID of the OTAU cluster on the client device, and the client device's short address.</p>
<h3><a class="anchor" id="isd_vs_pc"></a>
ISD and storage system interaction</h3>
<p>ISD receives commands from the storage system through UART (though it can be modified to use any serial interface). ISD reads from the serial interface and parses messages that should have the following structure:</p>
<div class="fragment"><pre class="fragment"><span class="keyword">struct </span>PACK
{
  uint8_t addrMode;                    <span class="comment">// 1-byte field</span>
  <a class="code" href="mac_addr_8h.html#a4c45604b4a2170c8689cda4b3f650646" title="Short address type declaration.">ShortAddr_t</a> shortAddress;            <span class="comment">// 2-byte field</span>
  <a class="code" href="mac_addr_8h.html#a5b2913b1523fd1ce0a399c4fb047cc8b" title="Extended address type declaration.">ExtAddr_t</a> extAddress;                <span class="comment">// 8-byte field</span>
  <a class="code" href="app_framework_8h.html#a6830f662c9ba99181b8f8ac6f6eda2c0" title="The type for holding profile ID.">ProfileId_t</a> profileId;               <span class="comment">// 2-byte field</span>
  uint8_t endpoint;                    <span class="comment">// 1-byte field</span>
  uint8_t dstEndpoint;                 <span class="comment">// 1-byte field</span>
  <a class="code" href="app_framework_8h.html#a6de6a020fadabae5228d009b790063b3" title="The type for holding cluster ID.">ClusterId_t</a> clusterId;               <span class="comment">// 2-byte field</span>
  uint8_t defaultResponse;             <span class="comment">// 1-byte field</span>
  IsdCommandOptions_t commandOptions;  <span class="comment">// 1-byte field</span>
  uint8_t commandId;                   <span class="comment">// 1-byte field</span>
  uint8_t recordsCount;                <span class="comment">// 1-byte field</span>
  uint8_t request[1];                  <span class="comment">// 1-byte field</span>
} IsdCommandRequest_t;
</pre></div><p>First eight fields are standard fields of a ZCL command request. The last field, <code>request</code>, is of unspecified length, indicating the byte from which the specific payload of the message begins.</p>
<p>The storage system sends three types of messages as responses to messages sent by ISD:</p>
<ul>
<li><em>Query next image response</em> <br/>
 The structure of payload is given by <a class="el" href="struct_z_c_l___otau_query_next_image_resp__t.html" title="Query Next Image Response Command.">ZCL_OtauQueryNextImageResp_t</a> type. Command ID equals <b>QUERY_NEXT_IMAGE_REQUEST_ID</b>.</li>
</ul>
<ul>
<li><em>Image block response</em> <br/>
 The structure of payload is given by <a class="el" href="struct_z_c_l___otau_image_block_resp__t.html" title="Image Block Response Command.">ZCL_OtauImageBlockResp_t</a> type. Command ID equals <b>IMAGE_BLOCK_REQUEST_ID</b>.</li>
</ul>
<ul>
<li><em>Upgrade end response</em> <br/>
 The structure of payload is given by <a class="el" href="struct_z_c_l___otau_upgrade_end_resp__t.html" title="Upgrade End Response Command.">ZCL_OtauUpgradeEndResp_t</a> type. Command ID equals <b>UPGRADE_END_REQUEST_ID</b>. </li>
</ul>
</div></div>
<hr style="border-top:1px solid #C4CFE5; margin-top:20px"/>
</body>
</html>
