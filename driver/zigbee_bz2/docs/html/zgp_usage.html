<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>PIC32CX-BZ Zigbee API Reference: ZGP device functionalities</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">PIC32CX-BZ Zigbee API Reference</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">ZGP device functionalities </div>  </div>
</div>
<div class="contents">
<div class="textblock"><p>The zigbee green power(ZGP) provides an interface to commission, control or get the information from the Green power device</p>
<p>Green Power Devices may harvest different amount of energy depending on the harvesting technology used. With its own available energy budget, each GPD has special requirements regarding the functionality it can implement. Due to the energy budget of the GPD, bidirectional communication is limited. To enable GPD to communicate to ZigBee network GPD frame is much shorter than the zigbee frame.</p>
<p>On the ZigBee network side, the GP functionality required on a ZigBee node in order to receive and process the GPDF, and then tunnel it, if required across multiple hops, in a normal ZigBee frame format to the paired node, referred to as the sink, which processes and acts upon the information sent by GPD.</p>
 
<hr style="border-top:1px solid #E0E0FF; margin-top:10px"/>

<span class="table_of_contents">Contents</span>
<ul class="table_of_contents">
	<li><a href="#GP_Infrastructure">GP infrastructure device types </a>
		<ul>
			<li><a href="#initialization">Initialization</a></li>
			<li><a href="#commissioning">Commissioning to GPD</a></li>
			<li><a href="#generic_infrastrcture">ZGP infrastructure generic APIs</a></li>
			
		</ul>
	</li>
	<li><a href="#ZGP_devices">ZGP devices</a>
		<ul>
			<li><a href="#channel_config">Channel configuration</a></li>
			<li><a href="#unidirectional">Uni directional commissioning</a></li>
			<li><a href="#bidirectional">Bi directional commissioning</a></li>
			<li><a href="#decomission">Decommissioning</a></li>
			<li><a href="#operation">GPD Operation</a></li>
			<li><a href="#generic_zgpdevice">ZGP device generic APIs</a></li>
		</ul>
	</li>
</ul>
<p></p>
 <span class="to_top"><a href="#">Back to top</a></span> <h2><a class="anchor" id="GP_Infrastructure"></a>
ZGP infrastructure</h2>
<h3><a class="anchor" id="initialization"></a>
Initialization</h3>
<p>1. Following public API is used to initialize the zgp high proxy which will do </p>
<ul>
<li>
Getting the green power cluster information and adding the event handler for the zgp proxy attribute event </li>
<li>
Initializing zgp high generic and cluster generic feature </li>
<li>
Initializing the zgp NVM table which contains the ID of GPD, security keys, frame counters and sink address list, commissioned id, endpoint etc </li>
<li>
Initializing the zgp client cluster </li>
</ul>
<div class="fragment"><pre class="fragment"><span class="keywordtype">void</span> <a class="code" href="zgp_infra_device_8h.html#a3ea2d1718f3ffd19cc7ee03f7834bc5e" title="To initialize high proxy.">ZGPH_ProxyBasicInit</a>(<span class="keywordtype">void</span>);
</pre></div><p> <b>Parameters:</b> </p>
<ul>
<li>
None </li>
</ul>
<p>2. Following public API is used to initialize the zgp high sink, which will do </p>
<ul>
<li>
Initializing the zgp server cluster </li>
</ul>
<div class="fragment"><pre class="fragment"><span class="keywordtype">void</span> <a class="code" href="zgp_infra_device_8h.html#ac47769b2bef77bbb5ddddb383050881f" title="To initialize high sink.">ZGPH_SinkBasicInit</a>(<span class="keywordtype">void</span>);
</pre></div><p> <b>Parameters:</b> </p>
<ul>
<li>
None </li>
</ul>
<p>3. Following public API is used to initialize the lowzgp(mainly dStub/cStub) </p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">void</span> <a class="code" href="zgp_low_gpdf_8h.html#aa4fa2997488608b89af6cbb79c1558f3" title="Init. low zgp.">ZGPL_Init</a>(<span class="keywordtype">void</span>);
</pre></div><p> <b>Parameters:</b> </p>
<ul>
<li>
None </li>
</ul>
 <span class="to_top"><a href="#">Back to top</a></span> <h3><a class="anchor" id="commissioning"></a>
Commissioning</h3>
<p>1. Following public API is used to put sink in commissioning mode. </p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">void</span> <a class="code" href="zgp_infra_device_8h.html#a39c118f3d58bf1ea9b2308284306a4d7" title="To put local sink in commissioning mode.">ZGPH_PutLocalSinkInCommissioningMode</a>(uint8_t options, uint8_t endPoint, <span class="keywordtype">bool</span> unicastComm);
</pre></div><p> <b>Parameters:</b> </p>
<ul>
<li>
options - commissioning mode options (bit fields according to the set bit fields) <ul>
<li>
uint8_t action : 1; </li>
<li>
uint8_t involveGPMinSecurity : 1; </li>
<li>
uint8_t involveGPMinPairing : 1; </li>
<li>
uint8_t involveProxies : 1; </li>
<li>
uint8_t reserved : 4; </li>
</ul>
</li>
<li>
endPoint - value of communicating endpoint </li>
<li>
unicastComm - true or false </li>
</ul>
<p>2. Following public API is used to send the zgp proxy commissioning mode command. </p>
<div class="fragment"><pre class="fragment"><a class="code" href="zcl_8h.html#ad5ed4e48a062501fc4f9a9378cffe0da" title="Enumerated status values used in ZCL.">ZCL_Status_t</a> <a class="code" href="zgp_cluster_8h.html#a51e8d6e7825b2c0929e824de68aa33b8" title="Send proxy commissioning mode command.">ZGPH_SendProxyCommissioningModeCommand</a>(uint8_t options, uint16_t commissioningWindow, uint8_t channel);
</pre></div><p> <b>Parameters:</b> </p>
<ul>
<li>
options - proxy options field </li>
<li>
commissioningWindow - commissioning window value </li>
<li>
channel - channel value </li>
</ul>
<p><b>Usage</b> </p>
<div class="fragment"><pre class="fragment"><span class="comment">//If involveProxies is enabled from the options in ZGPH_PutLocalSinkInCommissioningMode(uint8_t sinkCommModeOptions, uint8_t endPoint, bool unicastComm) API</span>

uint8_t options;
ZCL_GpProxyCommModeOptions_t *proxyOptions = (ZCL_GpProxyCommModeOptions_t *)&amp;options;

proxyOptions-&gt;action = sinkCommModeOptions-&gt;action;
proxyOptions-&gt;channelPresent = <span class="keyword">false</span>; <span class="comment">// As per the current spec., this is set to 0 always</span>
proxyOptions-&gt;exitMode = ON_FIRST_PAIRING_SUCCESS;
proxyOptions-&gt;unicastCommunication = unicastComm;

<a class="code" href="zgp_cluster_8h.html#a51e8d6e7825b2c0929e824de68aa33b8" title="Send proxy commissioning mode command.">ZGPH_SendProxyCommissioningModeCommand</a>(proxyOptions, COMMISSIONING_WINDOW_DEFAULT_VALUE_IN_MSEC , ZGP_PROXY_COMM_MODE_CHANNEL);
</pre></div><h3><a class="anchor" id="generic_infrastrcture"></a>
Generic ZGP infrstructure APIs</h3>
<p>1. Following public API is used to enable or disable the direct mode of GPDF, and it is applicable for the COMBO basic devices(proxy + sink). Depending upon this it will forward c-stub indication to d-stub block. </p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">void</span> <a class="code" href="zgp_low_8h.html#a637f7c50f37b51cb0f551f65d227bef3" title="Enable/Disable direct mode to receive GPDF.">ZGPL_EnableDisableDirectMode</a>(<span class="keywordtype">bool</span> enabled);
</pre></div><p> <b>Parameters:</b> </p>
<ul>
<li>
enabled - enable/disable flag </li>
</ul>
<p>2. Following public API is used to request the zgp simple descriptor to get the information like cluster ids, profile id and device id etc for the requested network address and end point. </p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">void</span> <a class="code" href="zgp_low_8h.html#ae845ce09589b94fb3e6def2bde3badc1" title="Sending simple descritor request.">ZGPL_SendSimpleDescReq</a>(<a class="code" href="mac_addr_8h.html#a4c45604b4a2170c8689cda4b3f650646" title="Short address type declaration.">ShortAddr_t</a> addr,uint8_t ep);
</pre></div><p> <b>Parameters:</b> </p>
<ul>
<li>
addr - Network address of the node </li>
<li>
ep - endpoint value </li>
</ul>
<p>3. Following public API Is used to broadcast the device announce of zgp to the network which will be called generally after successful zgp commissioning. </p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">void</span> <a class="code" href="zgp_low_8h.html#a28a46b90a1caf3c21e81361324294264" title="Sending device annce.">ZGPL_SendDeviceAnnounceCmd</a>(uint16_t nwkAddr, uint64_t extAddr);
</pre></div><p> <b>Parameters:</b> </p>
<ul>
<li>
nwkAddr - nwk addr to be placed in the device announce </li>
<li>
extAddr - ext addr to be placed in the device announce </li>
</ul>
<p>4. Following public API is used to send the zgp read attribute command with green power profile id, cluster id for the respective attribute id to the zigbee network. </p>
<div class="fragment"><pre class="fragment"><a class="code" href="zcl_8h.html#ad5ed4e48a062501fc4f9a9378cffe0da" title="Enumerated status values used in ZCL.">ZCL_Status_t</a> ZGPH_SendReadAttributeCommand(uint16_t addr, uint8_t dir, uint16_t attrId);
</pre></div><p> <b>Parameters:</b> </p>
<ul>
<li>
addr - Destination address </li>
<li>
dir - server to client or client to server </li>
<li>
attrId - Attribute id </li>
</ul>
<p>5. Following public API is used to send the zgp commands in raw mode with the payload </p>
<div class="fragment"><pre class="fragment"><a class="code" href="zcl_8h.html#ad5ed4e48a062501fc4f9a9378cffe0da" title="Enumerated status values used in ZCL.">ZCL_Status_t</a> <a class="code" href="zgp_cluster_8h.html#ae2e63a87b95f37319a05ed33f1580a9f" title="Send ZGP cluster command in raw mode.">ZGPH_SendCmdInRawMode</a>((uint16_t dstAddr, <span class="keywordtype">bool</span> dir, uint16_t cmdId, uint8_t payLoadLength, uint8_t  *payLoad);
</pre></div><p> <b>Parameters:</b> </p>
<ul>
<li>
dstAddr - Destination address </li>
<li>
dir - server to client or client to server </li>
<li>
cmdId - cluster command id </li>
<li>
payLoadLength - length of payload to be sent </li>
<li>
payLoad - payload to be sent </li>
</ul>
<p>6. A proxy node must keep information about the GP source nodes for which it acts as a proxy. This information is stored in a local 'proxy table', which contains an entry for each source node which is in direct range. A proxy table entry stores pairing information about the source node and the paired sink node, including the security requirements and communication mode. The proxy table is automatically built up by the Green Power cluster as a part of the commissioning process</p>
<p>Following public API is used to send request for zgp proxy table to the specific network address</p>
<div class="fragment"><pre class="fragment"><a class="code" href="zcl_8h.html#ad5ed4e48a062501fc4f9a9378cffe0da" title="Enumerated status values used in ZCL.">ZCL_Status_t</a> <a class="code" href="zgp_cluster_8h.html#a35ec9602fdc2c7a8133a7983ef5353b9" title="Sending proxy table request.">ZGPH_SendProxyTableRequest</a>(uint16_t addr, uint8_t options, uint64_t gpdId_Ieee, uint8_t ep, uint8_t index);
</pre></div><p> <b>Parameters:</b> </p>
<ul>
<li>
addr - Destination address </li>
<li>
options - options field </li>
<li>
gpdId_Ieee - gpd id or IEEE address </li>
<li>
ep - endpoint for IEEE address gpd </li>
<li>
index - index field </li>
</ul>
<p>7. A sink node must keep a record of the source nodes with which it is paired. This information is stored in a local ‘sink table’, which contains an entry for each paired source node. This table allows the sink node to determine whether a GP frame received from a source node (directly or via a proxy node) is intended for itself. The sink table is automatically built up by the Green Power cluster as a part of the commissioning process</p>
<p>Following public API is used to send request for zgp sink table information for the respective network address and end point. </p>
<div class="fragment"><pre class="fragment"><a class="code" href="zcl_8h.html#ad5ed4e48a062501fc4f9a9378cffe0da" title="Enumerated status values used in ZCL.">ZCL_Status_t</a> <a class="code" href="zgp_cluster_8h.html#a430bfaaeb3e7aa0047a6577ab3d7bcfc" title="Sending sink table request.">ZGPH_SendSinkTableRequest</a>(uint16_t addr, uint8_t options, uint64_t gpdId_Ieee, uint8_t ep, uint8_t index);
</pre></div><p> <b>Parameters:</b> </p>
<ul>
<li>
addr - Destination address </li>
<li>
options - options field </li>
<li>
gpdId_Ieee - gpd id or IEEE address </li>
<li>
ep - endpoint for IEEE address gpd </li>
<li>
index - index field </li>
</ul>
<p>8. Following public API is used to update sink entry locally on NVM based on the given action </p>
<div class="fragment"><pre class="fragment">ZGP_InfraDeviceStatus_t <a class="code" href="zgp_infra_device_8h.html#a8f1d4cd255e380278bff3a7dacaf69c2" title="To update sink entry locally on NVM based on the given action.">ZGPH_UpdateLocalSinkEntry</a>(zgpSinkTableEntry_t *sinkEntry, zgpSinkTableActions_t action);
</pre></div><p> <b>Parameters:</b> </p>
<ul>
<li>
sinkEntry - pointer to the sinkEntry to be updated </li>
<li>
action - Add/Replace/Remove </li>
</ul>
<p>9. Following public API is used to set the sink group id used for the GPD to be commissioned. </p>
<div class="fragment"><pre class="fragment">ZGP_InfraDeviceStatus_t <a class="code" href="zgp_infra_device_8h.html#aad2440866c6909d4535e3ef14fa5d71e" title=": To set sink group id used for the GPD to be commissioned">ZGPH_SetSinkGroupEntry</a>(<a class="code" href="app_framework_8h.html#a550c4defb5a054cf9c4bbe144f840422" title="The type for holding group address.">GroupAddr_t</a> sinkGroupId);
</pre></div><p> <b>Parameters:</b> </p>
<ul>
<li>
sinkGroupId - sink group Id to be set </li>
</ul>
<p>10. Following public API is used to set the assigned alias for the GPD to be commissioned. </p>
<div class="fragment"><pre class="fragment">ZGP_InfraDeviceStatus_t <a class="code" href="zgp_infra_device_8h.html#a21561fbd623394a9f70b4f6907b55775" title="To set assigned alias used for the GPD to be commissioned.">ZGPH_SetGPDAssignedAlias</a>(<a class="code" href="mac_addr_8h.html#a4c45604b4a2170c8689cda4b3f650646" title="Short address type declaration.">ShortAddr_t</a> gpdAssignedAlias);
</pre></div><p> <b>Parameters:</b> </p>
<ul>
<li>
gpdAssignedAlias - The commissioned 16-bit ID to be used as alias for this GPD </li>
</ul>
<p>11. Following public API is used to read the sink entry based on the index </p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">bool</span> <a class="code" href="zgp_infra_device_8h.html#adb97091ab43153990ab3e65153916bc2" title="To read the sink entry based on the index.">ZGPH_GetSinkTableEntryByIndex</a>(zgpSinkTableEntry_t *entry, uint8_t index);
</pre></div><p> <b>Parameters:</b> </p>
<ul>
<li>
entry - entry to be populated </li>
<li>
index - entry index </li>
</ul>
<p>12. Following public API is used to send gpPairingConfiguration command over the air </p>
<div class="fragment"><pre class="fragment">ZGP_InfraDeviceStatus_t <a class="code" href="zgp_infra_device_8h.html#afbb75a106c6cad497ef221c076ff2d39" title="To build and send ZGP pairing config command.">ZGPH_SendGpPairingConfigCmd</a>(<a class="code" href="aps_common_8h.html#a0bc5b23d1c85adcef057f8c04dfc5365" title="APS addressing modes.">APS_AddrMode_t</a> addrMode, <a class="code" href="union_a_p_s___address__t.html" title="Common APS address type.">APS_Address_t</a> *dstAddr, <a class="code" href="struct___z_g_p___pairing_config_cmd_info__t.html">ZGP_PairingConfigCmdInfo_t</a> pairingConfigCmdInfo, zgpCommReqAppInfo_t *commReqAppInfo, zgpEndpointInfo_t endPointInfo);
</pre></div><p> <b>Parameters:</b> </p>
<ul>
<li>
addrMode - address mode to be used over the air </li>
<li>
dstAddr - destination address of the remote device </li>
<li>
pairingConfigCmdInfo - pairingConfig command inputs </li>
<li>
commReqAppInfo - Application information </li>
<li>
endpointInfo - paired Endpoints information </li>
</ul>
<p>13. Following public API is used to flush out the tx request queued in tx queue. </p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">void</span> <a class="code" href="zgp_low_gpdf_8h.html#a84ab3c527b8ebc4ad6b1553e97f48c0a" title="Flushout gpTxqueue.">ZGPL_FlushTxQueue</a> (<span class="keywordtype">void</span>);
</pre></div><p> <b>Parameters:</b> </p>
<ul>
<li>
None </li>
</ul>
<p>14. Following public API is used to initiate gpd data request from high sink/proxy. </p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">void</span> <a class="code" href="zgp_low_gpdf_8h.html#a2bb60bb20e134198b9030e9c5c7a19da" title="GP-Data-Request(Raising from higher layer to dStub)">ZGPL_GpdfDataRequest</a>(<a class="code" href="struct_z_g_p___gpdf_data_req__t.html">ZGP_GpdfDataReq_t</a> *zgpGpdfDataReq);
</pre></div><p> <b>Parameters:</b> </p>
<ul>
<li>
zgpGpdfDataReq - data request paramters to be filled in queue </li>
</ul>
<p>15. Following public API is used to check the gpdf for duplicate packets. </p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">bool</span> <a class="code" href="zgp_low_gpdf_8h.html#a6515054c9c918d84dd2b5fa932aed3e8" title="check for duplicate packet">ZGPL_CheckForDuplicate</a>(ZGPL_DataInd_t *dStubDataInd);
</pre></div><p> <b>Parameters:</b> </p>
<ul>
<li>
dstubDataInd - dstub data indication paramters </li>
</ul>
<p>16. Following public API is used to derive the GPD security key from the network/group key.This API is mainly used by high Sink. </p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">void</span> <a class="code" href="zgp_low_gpdf_8h.html#ad06ee5d7e8a13c77fd3d7a12e3ba524a" title="To derive the GPD security key from network/group key. This is mainly used by high sink...">ZGPL_KeyDerivationHmac</a>(zgpSinkTableEntry_t* sinkTableEntry, uint8_t *derivedKey, <span class="keywordtype">void</span> (*keyedHashMacCb)(<span class="keywordtype">void</span>));
</pre></div><p> <b>Parameters:</b> </p>
<ul>
<li>
sinkTableEntry - pointer to the sinkTableEntry </li>
<li>
derivedKey - key to be derived </li>
<li>
sinkTableEntry - callback function </li>
</ul>
<p>17. Following public API is used to set the proxy/sink mode(commissioning/operational) </p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">void</span> <a class="code" href="zgp_low_8h.html#a1fed3e416a7c212f9d1c1d8681e1f2d4" title="To set the Device in operational/Commissioning Mode.">ZGPL_SetDeviceMode</a>(<span class="keywordtype">bool</span> isProxy, zgpMode_t mode);
</pre></div><p> <b>Parameters:</b> </p>
<ul>
<li>
isProxy - true for proxy, false for sink </li>
<li>
mode - commissioning/operational </li>
</ul>
<p>18. Following public API is used to get the proxy/sink mode(commissioning/operational) </p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">void</span> <a class="code" href="zgp_low_8h.html#a8b62098f94ad4bbddfc7b611d7cf0bbf" title="To get the Device Mode (operational/Commissioning Mode)">ZGPL_GetDeviceMode</a>(<span class="keywordtype">bool</span> isProxy, zgpMode_t mode);
</pre></div><p> <b>Parameters:</b> </p>
<ul>
<li>
isProxy - true for proxy, false for sink </li>
<li>
mode - commissioning/operational </li>
</ul>
<p>19. Following public API is used to check whether the given srcId is valid or not considering frame type </p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">bool</span> <a class="code" href="zgp_low_8h.html#aeb98e741e1795165b9712bc5783f0fca" title="To check whether the SrcID is valid or not considering the Frame Type.">ZGPL_IsValidSrcId</a>(uint32_t srcId, ZGP_FrameType_t frameType, <span class="keywordtype">bool</span> isPairingReq);
</pre></div><p> <b>Parameters:</b> </p>
<ul>
<li>
srcId - GPD srcId </li>
<li>
frameType - Maintanence Frame/Data Frame </li>
<li>
isPairingReq - rcId received in PairingConfig/Commissioning </li>
</ul>
<p>20. Following public API is used to check whether the given key is valid or not </p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">bool</span> <a class="code" href="zgp_low_8h.html#a24c58b638eac4a9000ef888b9927aeb1" title="To check whether the key is valid or not.">ZGPL_IskeyValid</a>(uint8_t *key);
</pre></div><p> <b>Parameters:</b> </p>
<ul>
<li>
key - key to be validated </li>
</ul>
<p>21. Following public API is used to derive the alias from the given gpdId </p>
<div class="fragment"><pre class="fragment">uint16_t <a class="code" href="zgp_low_8h.html#a3fe32c981044c6d33413aedf8d3ddd5c" title="To derive alias addr for the given srcId/Ieee addr.">ZGPL_GetAliasSourceAddr</a>(gpdId_t *gpdId);
</pre></div><p> <b>Parameters:</b> </p>
<ul>
<li>
gpdId - gpdId from which the alias has to be derived </li>
</ul>
 <span class="to_top"><a href="#">Back to top</a></span> <h3><a class="anchor" id="nvm_table"></a>
NVM_Table API's</h3>
<p>Following sections explains about the API's usage with respect to NVM table</p>
<p>1. Following public API is used to initilaize the NVM Table </p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">void</span> <a class="code" href="zgp_low_nvm_table_8h.html#ad630231433d631f1cf4f8dea5c33893b" title="Initialize zgp NVM table.">ZGPL_NvmTableInit</a> (<span class="keywordtype">void</span>);
</pre></div><p> <b>Parameters:</b> </p>
<ul>
<li>
none </li>
</ul>
<p>2. Following public API is used to reset all parameters of the given entry to init value. </p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">void</span> <a class="code" href="zgp_low_nvm_table_8h.html#a9df5913738752efa6ca22c67a4974fa9" title="To reset all the parameters of the given entry to init value.">ZGPL_ResetTableEntry</a> (<span class="keywordtype">void</span> *entry, ZGP_TableType_t tableType);
</pre></div><p> <b>Parameters:</b> </p>
<ul>
<li>
entry - entry to be reset </li>
<li>
tableType - sink/proxy entry </li>
</ul>
<p>3. Following public API is used to fetch the total no.of non empty entries.This is mainly used by high proxy/sink while sending sink/proxy table responses </p>
<div class="fragment"><pre class="fragment">uint8_t <a class="code" href="zgp_low_nvm_table_8h.html#ad1dad2a15247a731aa182db6603087bd" title="To fetch the total no. of non-empty entries. This is mainly used by high sink/proxy while sending sin...">ZGPL_TotalNonEmptyEntries</a>(<span class="keywordtype">bool</span> isProxyTable);
</pre></div><p> <b>Parameters:</b> </p>
<ul>
<li>
isProxyTable - proxy/sink entry </li>
</ul>
<p>4. Following public API is used to add/update the proxy/sink entry on NVM. </p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">bool</span> <a class="code" href="zgp_low_nvm_table_8h.html#af4abe2daa87184d848c21f105b92ce0d" title="To add/update proxy/sink entry on NVM.">ZGPL_AddOrUpdateTableEntryOnNvm</a>(<span class="keywordtype">void</span> *entryPtr, ZGP_TableUpdateAction_t action, ZGP_TableType_t tableType);
</pre></div><p> <b>Parameters:</b> </p>
<ul>
<li>
entryPtr - pointer to the entry </li>
<li>
action - to be performed on the entry </li>
<li>
tableType - proxy or sink entry </li>
</ul>
<p>5. Following public API is used to read the proxy/sink entry from NVM. </p>
<div class="fragment"><pre class="fragment">ZGP_ReadOperationStatus_t <a class="code" href="zgp_low_nvm_table_8h.html#a84ba0b3ce65a60d8d676e8702ef6cff0" title="To read a proxy/sink entry from NVm.">ZGPL_ReadTableEntryFromNvm</a>(<span class="keywordtype">void</span> *entryPtr, <a class="code" href="struct___z_g_p___table_operation_field__t.html">ZGP_TableOperationField_t</a> tableOperationField , gpdId_t *gpdId, uint8_t endPoint);
</pre></div><p> <b>Parameters:</b> </p>
<ul>
<li>
entryPtr - entry to be filled </li>
<li>
tableOperationField - filter fields for read operation </li>
<li>
gpdId - pointer to the addr info </li>
<li>
endPoint - GPD end point </li>
</ul>
<p>6. Following public API is used to delete the sink/proxy entry from NVM. </p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">bool</span> <a class="code" href="zgp_low_nvm_table_8h.html#ad9b6b41fb6acc92dd8f4621fa3709af3" title="To delete proxy/sink entry.">ZGPL_DeleteTableEntryFromNvm</a>(<a class="code" href="struct___z_g_p___table_operation_field__t.html">ZGP_TableOperationField_t</a> filterField, gpdId_t *gpdId, uint8_t endPoint);
</pre></div><p> <b>Parameters:</b> </p>
<ul>
<li>
tableOperationField - filter fields for read operation </li>
<li>
gpdId - pointer to the addr info </li>
<li>
endPoint - GPD end point </li>
</ul>
<p>7. Following public API is used to read/update frame counter on NVM. </p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">bool</span> <a class="code" href="zgp_low_nvm_table_8h.html#a8bc3f6adea3f3a414534d7911abdccf9" title="To read/update frameCounter.">ZGPL_FrameCounterReadorUpdateOnNvm</a>(uint32_t *frameCounter, <a class="code" href="struct___z_g_p___table_operation_field__t.html">ZGP_TableOperationField_t</a> tableOperationField , gpdId_t *gpdId, uint8_t endPoint, <span class="keywordtype">bool</span> isUpdateOperation);
</pre></div><p> <b>Parameters:</b> </p>
<ul>
<li>
frameCounter - frameCounter to be updated/read </li>
<li>
tableOperationField - filter fields for read operation </li>
<li>
gpdId - pointer to the addr info </li>
<li>
isUpdateOperation - true for update,false for read </li>
</ul>
<p>8. Following public API is used to check whether the pairing info in the sink entry is empty or not. This is used by high/low zgp while processing sink entry. </p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">bool</span> <a class="code" href="zgp_low_nvm_table_8h.html#a5ee4f3ed91bdede4b67b6d138b16b588" title="To check whether pairing info in the sink entry is empty or not.">ZGPL_SinkEntryIsPairingInfoEmpty</a>(zgpSinkTableEntry_t *currEntry);
</pre></div><p> <b>Parameters:</b> </p>
<ul>
<li>
currEntry - entry address </li>
</ul>
<p>9. Following public API is used to add the group entry to the given sink entry. </p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">bool</span> <a class="code" href="zgp_low_nvm_table_8h.html#a369ec85750d4328f4fcddf431d30c264" title="add sink group entry to the sink table entry">ZGPL_AddSinkGroupEntry</a>(zgpSinkTableEntry_t *currEntry, zgpSinkGroup_t *groupEntry);
</pre></div><p> <b>Parameters:</b> </p>
<ul>
<li>
currEntry - entry address </li>
<li>
groupEntry - group entry id to be added </li>
</ul>
<p>10. Following public API is used to delete all the table entries </p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">void</span> ZGP_ResetTableToFN(<span class="keywordtype">void</span>);
</pre></div><p> <b>Parameters:</b> </p>
<ul>
<li>
none </li>
</ul>
 <span class="to_top"><a href="#">Back to top</a></span> <h2><a class="anchor" id="ZGP_devices"></a>
ZGP devices</h2>
<p>Following sections explains about the types of commissioning, steps involved and related APIs</p>
<h3><a class="anchor" id="channel_config"></a>
1. Channel configuration</h3>
<p>Initial step in commissioning procedure is to put the target sink device in commissioning mode. If the ZGP device have no idea about the operating channel of target sink then the ZGPD will send channel request command in multiple channels which is enabled in channel mask to get channel configuration from sink/proxy </p>
<div class="fragment"><pre class="fragment">AppMem_t appMem;
appMem.zgpReq.zgpChannelReq.firstRxChannel = firstRxChannel;
appMem.zgpReq.zgpChannelReq.secondRxChannel = secondRxChannel;
appMem.zgpReq.zgpChannelReq.ZGP_ChannelReqConf = channelReqConf;
ZGP_ChannelReq(&amp;appMem.zgpReq.zgpChannelReq);
</pre></div><p>It is recommended to use the same channel for firstRxChanneland secondRxChannel to avoid the sink/proxy to switch the channel frequently. For each channel enabled in the channel mask, GPD sends a channel request.When the current channel is one of the rxChannel (firstRxChannel or secondRxChannel), more than one channel requests will be sent (usually two) then GPD opens its reception window for configured duration. GPD indicates its availability for reception in Extended Frame control field of channel request command by setting the RxAfterTx bit</p>
<p>After receiving channel request, sink prepares the channel configuration and delivers it to GPD by switching to GPD’s Rx channel for small duration (5sec). Once after receiving the channel configuration from sink, GPD will change its operating channel to sink’s operating channel.In case of proxy based commissioning, channel requests from GPD is forwarded to sink via GPcommissioning Notification command. Sink responds with GP response command carrying the channel configuration. After this it is proxy’s responsibility to deliver the channel config to GPD. Hence as explained above instead of sink, proxy will change its channel to GPD’s Rx channel to deliver channel config. Once it is delivered, the devices start operating in the operational channel.</p>
<h3><a class="anchor" id="unidirectional"></a>
2. Unidirectional commissioning</h3>
<p>Aftet channel configuration, GPD can get commissioned with sink directly or via proxy.For unidirectional commissioning, GPD sends a commissioning command reseting RxAfterTx bit and including all device details like device type, security level, security key type, security key etc. Sink will verify the device details, security key and accepts the commissioning. Sink makes a new entry for this device in its sink table and also broadcasts GP pairing command to announce the commissioning of this new GPD.</p>
<div class="fragment"><pre class="fragment"><span class="comment">//parameters for commissioning request</span>
ZGP_CommissioningReq_t zgpCommissionReq;
<span class="comment">// define confirmation callback</span>
<span class="keyword">static</span> <span class="keywordtype">void</span> commissionConfirm(ZGP_CommissionConf_t *conf)
{
 . . .
}
. . .
{
   zgpCommissionReq.panIdReq = <span class="keyword">false</span>;
   zgpCommissionReq.keyReq = <span class="keyword">false</span>;
   zgpCommissionReq.fixedLocation = <span class="keyword">true</span>;
   zgpCommissionReq.deviceId = 0x02;  <span class="comment">// onoff switch</span>
   zgpCommissionReq.ZGP_CommissionConf = commissionConfirm;
   <span class="comment">//Reset CS_ZGP_RX_AFTER_TX, for unidirectional commissioning</span>
   uint8_t rxAfterTx = 0;
   <a class="code" href="group__cs__functions.html#ga3106f18b9723751a9a5fa9deefa9d906" title="Sets a value of a certain Configuration Server parameter specified by its ID.">CS_WriteParameter</a>(CS_ZGP_RX_AFTER_TX_ID,&amp; rxAfterTx); 
   <span class="comment">// Initiate commissioning</span>
   ZGP_CommissionReq(&amp;zgpCommissionReq);
}
</pre></div><h3><a class="anchor" id="bidirectional"></a>
3. Bidirectional commissioning</h3>
<p>For bidirectional commissioning, GPD sends a commissioning command with out reseting RxAfterTx bit and by including all device details like device type, security level, security key type, security key etc. Sink will verify the details and responds with Commissioning reply. Commissioning reply might include a new security key and PAN id if the same are requested in the commissioning packet. When GPD receives and processes this commissioning reply, it sends a success command with a new key and PANId. On successfully decrypting the success packet from GPD, sink adds a new entry in its sink table and broadcasts GP pairing for this device</p>
<div class="fragment"><pre class="fragment">zgpCommissionReq.panIdReq = <span class="keyword">true</span>;
zgpCommissionReq.keyReq = <span class="keyword">true</span>;
<span class="comment">//set CS_ZGP_RX_AFTER_TX, for bidirectional commissioning</span>
uint8_t rxAfterTx = 1;
<a class="code" href="group__cs__functions.html#ga3106f18b9723751a9a5fa9deefa9d906" title="Sets a value of a certain Configuration Server parameter specified by its ID.">CS_WriteParameter</a>(CS_ZGP_RX_AFTER_TX_ID,&amp; rxAfterTx); 
<span class="comment">// Initiate commissioning</span>
ZGP_CommissionReq(&amp;zgpCommissionReq);
</pre></div><p>Commissioning mode shall also be setusing the CS_ZGP_COMMISSIONING_TYPE macro.</p>
<h3><a class="anchor" id="decomission"></a>
4. Decommissioning</h3>
<p>In order to decommission a GP device, the GPD needs to send a Decommissioning command to target sink using the API ZGP_DecommissioningReq (). On receiving the decommissioning command sink device will remove the GPD’s entry from the sink table and sends a pairing command with this removed GPD information.</p>
<div class="fragment"><pre class="fragment"><span class="comment">//parameters for decommissioning request</span>
ZGP_DecommissioningReq_t zgpDeCommissionReq;
. . .
<span class="comment">// assign a callback</span>
zgpDeCommissionReq.ZGP_DecommissioningConf = deCommissionConfirm;
ZGP_DecommissioningReq(&amp;zgpDeCommissionReq);
</pre></div><p> To add or remove GPD entry from sink table, pairing configuration command can also be sent to remove/add a GPD entry.</p>
<h3><a class="anchor" id="operation"></a>
5. GPD Operation</h3>
<p>Based on the device type of a GPD it can act as OnOff switch, Temperature sensor, illuminance sensor etc. After commissioning the device might send different commands and attribute reporting according to the device type.</p>
<p>For unidirectional case,GPD devices are capable of reporting its attribute values to the target device periodically. For example a temperature sensor device can update the temperature attribute periodically to the target devices with which it got commissioned. On/off commands from a GPD Switch devices to sink are also unidirectional commands</p>
<p>For Bidirectional case,Sink device can initiate a read attribute, write attribute commands to the required GPD with attribute ID. GPD device on receiving the command, forms the response and sends to the sink. But to initiate a read/write attribute command from sink, GPD must send a frame with rxAfterTx =1.</p>
<p>To send a ZGP data from application, ZGP_DataReq API can be used </p>
<div class="fragment"><pre class="fragment"><span class="comment">// Parameters for initiating ZGP data req</span>
<a class="code" href="zgpd_data_handler_8h.html#aa6378ca0693ea12f3e8b847cc0576add" title="* This will be used for ZGP data request*/">ZGP_DataReq_t</a> zgpDataReq;
<span class="comment">// Data confirmation callback</span>
<span class="keywordtype">void</span> ZGP_DataConf(ZGP_DataConf_t *conf)
{
  . . .
}
. . .
Payload[1] = {0x21}; <span class="comment">// On command</span>
zgpDataReq.appId = CS_ZGP_APPID;
zgpDataReq.srcId = CS_ZGP_SRCID;
zgpDataReq.asduLength = 1;
zgpDataReq.asdu = Payload; 
zgpDataReq.ZGP_DataConf = ZGP_DataConf;
<a class="code" href="zgpd_data_handler_8h.html#adcfae0b1d24fad398bfd9c24147c1ae0" title="to request zgp to do data transmission">ZGP_DataReq</a>(&amp;zgpReq.zgpDataReq);
</pre></div><p>By using the following public API user can register a commissioning callback which will be used in bidirectional commissioning. </p>
<div class="fragment"><pre class="fragment">ZGP_Status_t ZGP_SubscribeCommissioning(commissioningCallback_t zgpCommissioningCB);
</pre></div><p>To deregister a commissioning callback can be done using the following API </p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">void</span> ZGP_UnsubscribeCommissioning(<span class="keywordtype">void</span>);
</pre></div><h3><a class="anchor" id="generic_zgpdevice"></a>
Generic ZGP device APIs</h3>
<p>1. Following public API is used to raise the ZGP reset request. </p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">void</span> ZGP_ResetReq(<a class="code" href="struct___z_g_p___reset_req__t.html" title="* This will be used for ZGP data request*/">ZGP_ResetReq_t</a> *reqParams);
</pre></div><p> <b>Parameters:</b> </p>
<ul>
<li>
reqParams - structure having the zgp reset parameters </li>
</ul>
<p>2. Following public API is used to configure the zgp channel </p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">void</span> ZGP_SetChannel(uint8_t channel);
</pre></div><p> <b>Parameters:</b> </p>
<ul>
<li>
channel - channel value to be configured </li>
</ul>
<p>3. Following public API is used to get the configured zgp channel </p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">void</span> ZGP_GetChannel(uint8_t *channel);
</pre></div><p> <b>Parameters:</b> </p>
<ul>
<li>
channel - location to store cahnnel value </li>
</ul>
<p>4. Following public API is used to check whether the zgp device is in factory new state or not. </p>
<div class="fragment"><pre class="fragment"><span class="keywordtype">bool</span> ZGP_IsDeviceFactoryNew (<span class="keywordtype">void</span>);
</pre></div><p> <b>Parameters:</b> </p>
<ul>
<li>
None </li>
</ul>
 <span class="to_top"><a href="#">Back to top</a></span>  </div></div>
<hr style="border-top:1px solid #C4CFE5; margin-top:20px"/>
</body>
</html>
