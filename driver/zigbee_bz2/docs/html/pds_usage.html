<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>PIC32CX-BZ Zigbee API Reference: Persistent Data Server</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">PIC32CX-BZ Zigbee API Reference</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">Persistent Data Server </div>  </div>
</div>
<div class="contents">
<div class="textblock"><p>Persistence Data Server (PDS) provides API for managing, reading and writing data to non-volatile (NV) memory.</p>
<p>Although HAL component has functions for reading and writing EEPROM, it is strongly recommended to use PDS component for such purposes, because HAL functions access memory directly at given address and hence there is a risk of overwriting internal stack-specific variables.</p>
<p><span class="table_of_contents">References</span> </p>
<ul>
<li>
<a class="el" href="group__pds.html">PDS functions</a> </li>
<li>
PDS memory IDs </li>
</ul>
 
<hr style="border-top:1px solid #E0E0FF; margin-top:10px"/>

<span class="table_of_contents">Contents</span>
<ul class="table_of_contents">
  <li><a href="#store_stack_params">Saving stack data</a></li>
  <li><a href="#store_app_data">Saving application data</a></li>
</ul>
<p></p>
 <span class="to_top"><a href="#">Back to top</a></span>  <h2><a class="anchor" id="store_stack_params"></a>
Saving stack data</h2>
<p>The Microchip Zigbee stack does not save its parameters and internal tables in the NV memory unless the application uses the PDS API. Individual pices of data (parameters, variables) are called files, and groups of files are called directories. For example, BC_ALL_MEMORY_MEM_ID is an indentifier for the group of all stack files. Files and directiries are identified via memory IDs defined in the <code>pdsMemIds.h</code> file.</p>
<p>Files are written to the NV storage when the PDS_Store() function is called. Besides, PDS may be configured to store stack parameters in the NV memroy automatically: either by timer with a fixed interval or upon specific events. In the former case call the PDS_StoreByTimer() function, specifying the interval in milliseconds and an object to store. For the latter, use the PDS_StoreByEvents() function, providing an object to store.</p>
<p>Note that the described functions do not cofigure automatic restoring of data from the NV storage. Data restoring must be initiated by the application, for example, during application initialization, by calling the PDS_Restore() function.</p>
<p>The following example shows typical action that the application using PDS may perform during initialization (the code may be placed in <a class="el" href="sys_task_manager_8h.html#aec14264f3afa11a970347e765c44d9ef">APL_TaskHandler()</a> function):</p>
<div class="fragment"><pre class="fragment"><span class="comment">//Request storing of general stack parameters and group, permission and</span>
<span class="comment">//security tables - to be able to rejoin the same network in case of power</span>
<span class="comment">//failure (bindings are lost)</span>
PDS_StoreByEvents(BC_NETWORK_REJOIN_PARAMS_MEM_ID);

<span class="comment">//If the data have been stored in the NV memory previously and</span>
<span class="comment">//can be restored now then restore data</span>
<span class="keywordflow">if</span> (PDS_IsAbleToRestore(BC_NETWORK_REJOIN_PARAMS_MEM_ID))
  PDS_Restore(BC_NETWORK_REJOIN_PARAMS_MEM_ID);
</pre></div> <span class="to_top"><a href="#">Back to top</a></span>  <h2><a class="anchor" id="store_app_data"></a>
Saving application data</h2>
<p>An application may store arbitrary data, using the PDS API. To store its data the application may use one of two approaches: </p>
<ul>
<li>Use PDS_ReadUserData()/PDS_WriteUserData() functions to store data in the not occupied part of the NV memory and access data directly at a given offset </li>
<li>Define files and directories and use the same API as for the stack data.</li>
</ul>
<p>The application should first define file descriptors, using the <code>PDS_DECLARE_FILE</code> macro, providing it with the variable that should associated with the file, its size, adn special file marks, then define a directory descriptor, using the <code>PDS_DECLARE_DIR</code> macro, and provide the list of files to be included in the directory in the <code>PROGMEM_DECLARE</code> file. Examples can be found in the <code><a class="el" href="cs_persistent_mem_8c_source.html">csPersistentMem.c</a></code> file.</p>
<p>Once files and directories are defined (note that this can only happen at compile time), to store data contained in data variables use the PDS_Store() function. The application may also use the PDS_StoreByTimer() function to configure periodical storing of application data to the NV memory. To be able to store application data by events, modify the <code>pdsEvents.c</code> file located at <code>\Components\PersistDataServer\src\</code>. The application's file iidentifiers should be added to lines with required events.</p>
<p>To restore data back from EEPROM to the data variables use the PDS_Restore() function. </p>
</div></div>
<hr style="border-top:1px solid #C4CFE5; margin-top:20px"/>
</body>
</html>
