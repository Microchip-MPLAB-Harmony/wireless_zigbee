<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>PIC32CX-BZ Zigbee API Reference: Security</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">PIC32CX-BZ Zigbee API Reference</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
</div>
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Security</div>  </div>
<div class="ingroups"><a class="el" href="group__aps.html">APS functions</a></div></div>
<div class="contents">

<p>APS functions related to security: setting, switching and requesting security keys.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct___a_p_s___key_handle__t.html">APS_KeyHandle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__aps__security.html#ga4d97ec9bad11b340c8fa114db1d7a92c">APS_SetLinkKey</a> (const <a class="el" href="mac_addr_8h.html#a5b2913b1523fd1ce0a399c4fb047cc8b">ExtAddr_t</a> *const deviceAddress, const uint8_t *const linkKey)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a link key for the device with a given extended address.  <a href="#ga4d97ec9bad11b340c8fa114db1d7a92c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct___a_p_s___key_handle__t.html">APS_KeyHandle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__aps__security.html#gaf6bad000710b8a34e6493005132fe288">APS_SetMasterKey</a> (const <a class="el" href="mac_addr_8h.html#a5b2913b1523fd1ce0a399c4fb047cc8b">ExtAddr_t</a> *const deviceAddress, const uint8_t *const masterKey)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a master key for the device with a given extended address.  <a href="#gaf6bad000710b8a34e6493005132fe288"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct___a_p_s___key_handle__t.html">APS_KeyHandle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__aps__security.html#ga3229d2abe9efd3d4e35cd4338cfaf988">APS_FindKeys</a> (const <a class="el" href="mac_addr_8h.html#a5b2913b1523fd1ce0a399c4fb047cc8b">ExtAddr_t</a> *const deviceAddress)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the master key or the link key corresponding to a given extended address.  <a href="#ga3229d2abe9efd3d4e35cd4338cfaf988"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__aps__security.html#ga7d48f855d7bdc744b7f3bc5e5e9d57e4">APS_GetMasterKey</a> (const <a class="el" href="struct___a_p_s___key_handle__t.html">APS_KeyHandle_t</a> handle)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the master key value by a given key handle.  <a href="#ga7d48f855d7bdc744b7f3bc5e5e9d57e4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__aps__security.html#gaf284854b8e67a19aa3ecdab2271b0705">APS_GetLinkKey</a> (const <a class="el" href="struct___a_p_s___key_handle__t.html">APS_KeyHandle_t</a> handle)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the link key value by a given key handle.  <a href="#gaf284854b8e67a19aa3ecdab2271b0705"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__aps__security.html#gae70f5ad61efae9a6f5d9b312a9a885ca">APS_DeleteKeyPair</a> (<a class="el" href="mac_addr_8h.html#a5b2913b1523fd1ce0a399c4fb047cc8b">ExtAddr_t</a> *const deviceAddress, const bool notify)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete key-pair - master and link keys.  <a href="#gae70f5ad61efae9a6f5d9b312a9a885ca"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct___a_p_s___key_handle__t.html">APS_KeyHandle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__aps__security.html#ga8e717dc80d8b9937b446523e0ec2a758">APS_NextKeys</a> (const <a class="el" href="struct___a_p_s___key_handle__t.html">APS_KeyHandle_t</a> handle)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get next key handle.  <a href="#ga8e717dc80d8b9937b446523e0ec2a758"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__aps__security.html#ga8c5b6259fe787815cd4317c41570a655">APS_RequestKeyReq</a> (<a class="el" href="struct_a_p_s___request_key_req__t.html">APS_RequestKeyReq_t</a> *req)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Request either the active network key or a new application link key.  <a href="#ga8c5b6259fe787815cd4317c41570a655"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__aps__security.html#ga1bb21d70018271538c85d9859b8ee5b6">APS_SwitchKeyReq</a> (<a class="el" href="struct_a_p_s___switch_key_req__t.html">APS_SwitchKeyReq_t</a> *req)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a command to a remote device to switch to another network key.  <a href="#ga1bb21d70018271538c85d9859b8ee5b6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__aps__security.html#ga80e8e102dfc86765d25af1c438b2aed3">APS_TransportKeyReq</a> (<a class="el" href="struct_a_p_s___transport_key_req__t.html">APS_TransportKeyReq_t</a> *const req)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfers a security key to a specified node.  <a href="#ga80e8e102dfc86765d25af1c438b2aed3"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<p>APS functions related to security: setting, switching and requesting security keys. </p>
<p>Some functions that are not intended to be used by the application but internally by the stack only are not listed.</p>
<p>See more information on API usage with code examples on <a class="el" href="aps_usage.html">Using the APS component</a>. </p>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga4d97ec9bad11b340c8fa114db1d7a92c"></a><!-- doxytag: member="apsCryptoKeys.h::APS_SetLinkKey" ref="ga4d97ec9bad11b340c8fa114db1d7a92c" args="(const ExtAddr_t *const deviceAddress, const uint8_t *const linkKey)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct___a_p_s___key_handle__t.html">APS_KeyHandle_t</a> APS_SetLinkKey </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="mac_addr_8h.html#a5b2913b1523fd1ce0a399c4fb047cc8b">ExtAddr_t</a> *const&#160;</td>
          <td class="paramname"><em>deviceAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *const&#160;</td>
          <td class="paramname"><em>linkKey</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets a link key for the device with a given extended address. </p>
<p>This function inserts a new entry into the APS key-pair set containing provided link key value and extended address.</p>
<p>The function shall be called to specify the trust center link key before performing network start if high security is used with <a class="el" href="cs_defaults_8h.html#a90c571c9ce64320c8418ad0ee9b71142" title="ZDO security status.">CS_ZDO_SECURITY_STATUS</a> set to 1 or standard security with link keys is used.</p>
<p>In high security, if the trust center link key is unavailable <a class="el" href="cs_defaults_8h.html#a90c571c9ce64320c8418ad0ee9b71142" title="ZDO security status.">CS_ZDO_SECURITY_STATUS</a> can be set to 2 or 3; in this case a master key is used to authenticate the joining device to launch link key establishment procedure with the trust center.</p>
<p>For communication with a node different from the trust center a separate link key is also needed (an application link key). If it is known to the application it shall be set with the use of this function. Otherwise, the application shall either apply a master key to launch link key establishment procedure (SKKE) with the partner node or request for a link key from the trust center.</p>
<p>A typical example of the function's usage is given below: </p>
<div class="fragment"><pre class="fragment"><a class="code" href="struct___a_p_s___key_handle__t.html">APS_KeyHandle_t</a> apsKeyHandle; <span class="comment">//A variable to hold a key handle</span>
<span class="comment">//Set a link key variable to a 16-byte value</span>
uint8_t linkKey[SECURITY_KEY_SIZE] = {0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa};
<span class="comment">//A variable for the trust center address predefined in ::CS_APS_TRUST_CENTER_ADDRESS.</span>
<a class="code" href="mac_addr_8h.html#a5b2913b1523fd1ce0a399c4fb047cc8b" title="Extended address type declaration.">ExtAddr_t</a> trustCenterAddr;

<span class="comment">//Read the trust center address</span>
<a class="code" href="group__cs__functions.html#ga0ea8ddc7bc41ce1c5ba556058ee1073b" title="Gets the value of the parameter specified by its ID and writes it to the provided address in memory...">CS_ReadParameter</a>(CS_APS_TRUST_CENTER_ADDRESS_ID, &amp;trustCenterAddr);
<span class="comment">//Set the trust center link key</span>
apsKeyHandle = <a class="code" href="group__aps__security.html#ga4d97ec9bad11b340c8fa114db1d7a92c" title="Sets a link key for the device with a given extended address.">APS_SetLinkKey</a>(&amp;trustCenterAddr, linkKey);

<span class="comment">//Check for errors</span>
<span class="keywordflow">if</span> (<a class="code" href="aps_crypto_keys_8h.html#a581d4c2657a00e894e650aeb41806c4b">APS_KEY_HANDLE_IS_VALID</a>(apsKeyHandle))
{
  ...
}
</pre></div><dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">deviceAddress</td><td><a class="el" href="_endian.html">[LE]</a> - pointer to extended (IEEE) device address </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">linkKey</td><td>- pointer to a new link key</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A valid key handle if operation is successfully completed otherwise invalid key handle (Use APS_KEY_HANDLE_IS_VALID to check it out). </dd></dl>

</div>
</div>
<a class="anchor" id="gaf6bad000710b8a34e6493005132fe288"></a><!-- doxytag: member="apsCryptoKeys.h::APS_SetMasterKey" ref="gaf6bad000710b8a34e6493005132fe288" args="(const ExtAddr_t *const deviceAddress, const uint8_t *const masterKey)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct___a_p_s___key_handle__t.html">APS_KeyHandle_t</a> APS_SetMasterKey </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="mac_addr_8h.html#a5b2913b1523fd1ce0a399c4fb047cc8b">ExtAddr_t</a> *const&#160;</td>
          <td class="paramname"><em>deviceAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *const&#160;</td>
          <td class="paramname"><em>masterKey</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sets a master key for the device with a given extended address. </p>
<p>This function inserts a new entry into the APS key-pair set containing provided master key value and extended address. Thus it specifies a master key used to launch link key establishment (SKKE) with the remote device with the corresponding extended address.</p>
<p>The function is used in high security with <a class="el" href="cs_defaults_8h.html#a90c571c9ce64320c8418ad0ee9b71142" title="ZDO security status.">CS_ZDO_SECURITY_STATUS</a> set to 2 or 3. If <a class="el" href="cs_defaults_8h.html#a90c571c9ce64320c8418ad0ee9b71142" title="ZDO security status.">CS_ZDO_SECURITY_STATUS</a> is set to 2, then before joining the network the device shall specify a master key value corresponding to the trust center using this function. The master key in pair with the joining device's extended address must be set on the trust center via this function as well. If <a class="el" href="cs_defaults_8h.html#a90c571c9ce64320c8418ad0ee9b71142" title="ZDO security status.">CS_ZDO_SECURITY_STATUS</a> is set to 3, then the master key must be set only on the trust center. In this case the trust center trasfers the master key to the device at the beginning of the authentication procedure.</p>
<p>The function can also be used to specify application master keys corresponding to devices different from the trust center. The need for this occurs when a link key for a remote device is unknown. The device shall set a master key value for a remote device with which it wishes to communicate and initiate the SKKE procedure to establish the link key by calling the APS_EstablishKeyReq() function before sending any data requests to the device.</p>
<p>See the example of usage below: </p>
<div class="fragment"><pre class="fragment"><a class="code" href="struct___a_p_s___key_handle__t.html">APS_KeyHandle_t</a> apsKeyHandle; <span class="comment">//A variable to hold a key handle</span>
<span class="comment">//Set a master key variable to a 16-byte value</span>
uint8_t masterKey[16] = {0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa};
<span class="comment">//Assume the remote node extended address is held by APP_EXT_ADDR constant</span>
<a class="code" href="mac_addr_8h.html#a5b2913b1523fd1ce0a399c4fb047cc8b" title="Extended address type declaration.">ExtAddr_t</a> partnerExtAddr = APP_EXT_ADDR;

apsKeyHandle = <a class="code" href="group__aps__security.html#gaf6bad000710b8a34e6493005132fe288" title="Sets a master key for the device with a given extended address.">APS_SetMasterKey</a>(&amp;partnerExtAddr, masterKey); <span class="comment">//Set the master key</span>

<span class="comment">//Check for errors</span>
<span class="keywordflow">if</span> (<a class="code" href="aps_crypto_keys_8h.html#a581d4c2657a00e894e650aeb41806c4b">APS_KEY_HANDLE_IS_VALID</a>(apsKeyHandle))
{
  ...
}
</pre></div><p> Note that the APP_EXT_ADDR constant shall contain a 64-bit value in the little endian format. For this purpose in the definition of the constant convert a common value to the little endian format using the CCPU_TO_LE64 format as follows: </p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#define APP_EXT_ADDR     CCPU_TO_LE64(0xAAAAAAAAAAAAAAAALL)</span>
</pre></div><p>An extended address corresponding to a given short address can be obtained through Device Discovery, while short addresses of devices supporting certain services can be discovered using Service Discovery.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">deviceAddress</td><td><a class="el" href="_endian.html">[LE]</a> - pointer to extended IEEE device address. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">masterKey</td><td>- pointer to new cryptographic master key.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Valid key handle if operation is successfully completed otherwise invalid key handle (Use APS_KEY_HANDLE_IS_VALID to check it out). </dd></dl>

</div>
</div>
<a class="anchor" id="ga3229d2abe9efd3d4e35cd4338cfaf988"></a><!-- doxytag: member="apsCryptoKeys.h::APS_FindKeys" ref="ga3229d2abe9efd3d4e35cd4338cfaf988" args="(const ExtAddr_t *const deviceAddress)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct___a_p_s___key_handle__t.html">APS_KeyHandle_t</a> APS_FindKeys </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="mac_addr_8h.html#a5b2913b1523fd1ce0a399c4fb047cc8b">ExtAddr_t</a> *const&#160;</td>
          <td class="paramname"><em>deviceAddress</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Find the master key or the link key corresponding to a given extended address. </p>
<p>The function is used to check whether the link key or the master key has been set for a given device identified by its extended address and to retrieve a handle to it if one exists. To check whether the key has been found use the APS_KEYS_FOUND macro. If the handle is valid an access to a key value is got via <a class="el" href="group__aps__security.html#ga7d48f855d7bdc744b7f3bc5e5e9d57e4" title="Get a pointer to the master key value by a given key handle.">APS_GetMasterKey()</a> or <a class="el" href="group__aps__security.html#gaf284854b8e67a19aa3ecdab2271b0705" title="Get a pointer to the link key value by a given key handle.">APS_GetLinkKey()</a>.</p>
<p>See the example: </p>
<div class="fragment"><pre class="fragment"><span class="comment">//Assume that the extended address of interest is held by APP_EXT_ADDR constant</span>
<a class="code" href="mac_addr_8h.html#a5b2913b1523fd1ce0a399c4fb047cc8b" title="Extended address type declaration.">ExtAddr_t</a> partnerExtAddr = APP_EXT_ADDR;

<span class="keywordflow">if</span> (!<a class="code" href="aps_crypto_keys_8h.html#a13f6a12c2990da1e8de138657abe016c">APS_KEYS_FOUND</a>(<a class="code" href="group__aps__security.html#ga3229d2abe9efd3d4e35cd4338cfaf988" title="Find the master key or the link key corresponding to a given extended address.">APS_FindKeys</a>(&amp;partnerExtAddr)))
{
  ... <span class="comment">//Perform required action, e.g. request for a link key, using APS_RequestKeyReq()</span>
}
</pre></div><dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">deviceAddress</td><td><a class="el" href="_endian.html">[LE]</a> - pointer to extended IEEE device address.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Valid key handle if any key is found otherwise invalid key handle (Use APS_KEYS_FOUND to check it out). </dd></dl>

</div>
</div>
<a class="anchor" id="ga7d48f855d7bdc744b7f3bc5e5e9d57e4"></a><!-- doxytag: member="apsCryptoKeys.h::APS_GetMasterKey" ref="ga7d48f855d7bdc744b7f3bc5e5e9d57e4" args="(const APS_KeyHandle_t handle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t* APS_GetMasterKey </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct___a_p_s___key_handle__t.html">APS_KeyHandle_t</a>&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get a pointer to the master key value by a given key handle. </p>
<p>The function returns a pointer to the section of memory containing the master key value for a given key handle. A key handle points to a certain entry in the APS key-pair set corresponding to a specific extended address. To obtain a key handle for a given extended address use the <a class="el" href="group__aps__security.html#ga3229d2abe9efd3d4e35cd4338cfaf988" title="Find the master key or the link key corresponding to a given extended address.">APS_FindKeys()</a> function.</p>
<p>Note that the received pointer must be only used to read the value and not to modify it.</p>
<p>Consider the example: </p>
<div class="fragment"><pre class="fragment"><span class="comment">//Search for keys associated with the provided extended address</span>
<span class="keyword">const</span> <a class="code" href="struct___a_p_s___key_handle__t.html">APS_KeyHandle_t</a> keyHandle = <a class="code" href="group__aps__security.html#ga3229d2abe9efd3d4e35cd4338cfaf988" title="Find the master key or the link key corresponding to a given extended address.">APS_FindKeys</a>(&amp;extAddr);

uint8_t *masterKey;

<span class="keywordflow">if</span> (<a class="code" href="aps_crypto_keys_8h.html#a13f6a12c2990da1e8de138657abe016c">APS_KEYS_FOUND</a>(keyHandle) &amp;&amp; NULL != (masterKey = <a class="code" href="group__aps__security.html#ga7d48f855d7bdc744b7f3bc5e5e9d57e4" title="Get a pointer to the master key value by a given key handle.">APS_GetMasterKey</a>(keyHandle)))
{
  ... <span class="comment">//A pointer to the master key value has been successfully captured</span>
}
</pre></div><dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- valid key handle.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A pointer to the master key or NULL if the key handle is invalid </dd></dl>

</div>
</div>
<a class="anchor" id="gaf284854b8e67a19aa3ecdab2271b0705"></a><!-- doxytag: member="apsCryptoKeys.h::APS_GetLinkKey" ref="gaf284854b8e67a19aa3ecdab2271b0705" args="(const APS_KeyHandle_t handle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t* APS_GetLinkKey </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct___a_p_s___key_handle__t.html">APS_KeyHandle_t</a>&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get a pointer to the link key value by a given key handle. </p>
<p>The function returns a pointer to the section of memory containing the link key value for a given key handle. A key handle points to a certain entry in the APS key-pair set corresponding to a specific extended address. To obtain a key handle for a given extended address use the <a class="el" href="group__aps__security.html#ga3229d2abe9efd3d4e35cd4338cfaf988" title="Find the master key or the link key corresponding to a given extended address.">APS_FindKeys()</a> function.</p>
<p>Note that the received pointer must be only used to read the value and not to modify it.</p>
<p>Consider the example: </p>
<div class="fragment"><pre class="fragment"><span class="comment">//Search for keys associated with the provided extended address</span>
<span class="keyword">const</span> <a class="code" href="struct___a_p_s___key_handle__t.html">APS_KeyHandle_t</a> keyHandle = <a class="code" href="group__aps__security.html#ga3229d2abe9efd3d4e35cd4338cfaf988" title="Find the master key or the link key corresponding to a given extended address.">APS_FindKeys</a>(&amp;extAddr);

uint8_t *linkKey;

<span class="keywordflow">if</span> (<a class="code" href="aps_crypto_keys_8h.html#a13f6a12c2990da1e8de138657abe016c">APS_KEYS_FOUND</a>(keyHandle) &amp;&amp; (linkKey = <a class="code" href="group__aps__security.html#gaf284854b8e67a19aa3ecdab2271b0705" title="Get a pointer to the link key value by a given key handle.">APS_GetLinkKey</a>(keyHandle)))
{
  ... <span class="comment">//A pointer to the link key value has been successfully captured</span>
}
</pre></div><dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- valid key handle.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>A pointer to the link key or NULL if the key handle is invalid </dd></dl>

</div>
</div>
<a class="anchor" id="gae70f5ad61efae9a6f5d9b312a9a885ca"></a><!-- doxytag: member="apsCryptoKeys.h::APS_DeleteKeyPair" ref="gae70f5ad61efae9a6f5d9b312a9a885ca" args="(ExtAddr_t *const deviceAddress, const bool notify)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool APS_DeleteKeyPair </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="mac_addr_8h.html#a5b2913b1523fd1ce0a399c4fb047cc8b">ExtAddr_t</a> *const&#160;</td>
          <td class="paramname"><em>deviceAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>notify</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Delete key-pair - master and link keys. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">deviceAddress</td><td><a class="el" href="_endian.html">[LE]</a> - pointer to extended IEEE device address. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">notify</td><td>- notify to upper layer or not.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>'true' if the key-pair is removed otherwise false. </dd></dl>

</div>
</div>
<a class="anchor" id="ga8e717dc80d8b9937b446523e0ec2a758"></a><!-- doxytag: member="apsCryptoKeys.h::APS_NextKeys" ref="ga8e717dc80d8b9937b446523e0ec2a758" args="(const APS_KeyHandle_t handle)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct___a_p_s___key_handle__t.html">APS_KeyHandle_t</a> APS_NextKeys </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct___a_p_s___key_handle__t.html">APS_KeyHandle_t</a>&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get next key handle. </p>
<div class="fragment"><pre class="fragment"> Example:
    <a class="code" href="struct___a_p_s___key_handle__t.html">APS_KeyHandle_t</a> handle = <a class="code" href="aps_crypto_keys_8h.html#a10dfee2315fd471b723df2254b8f980b">APS_KEY_PAIR_INITIAL</a>;

    <span class="keywordflow">while</span> (<a class="code" href="aps_crypto_keys_8h.html#a13f6a12c2990da1e8de138657abe016c">APS_KEYS_FOUND</a>(handle = <a class="code" href="group__aps__security.html#ga8e717dc80d8b9937b446523e0ec2a758" title="Get next key handle.">APS_NextKeys</a>(handle)))
    {
      linkKey = <a class="code" href="group__aps__security.html#gaf284854b8e67a19aa3ecdab2271b0705" title="Get a pointer to the link key value by a given key handle.">APS_GetLinkKey</a>(handle);
      <span class="keywordflow">if</span> (NULL != linkKey)
        ...
      ...
    }
</pre></div><dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>- handle of previous key-pair or APS_KEY_PAIR_INITIAL if it's initial call.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>if next key-pair is found then return valid key handle otherwise return APS_KEY_PAIR_FINISH. </dd></dl>

</div>
</div>
<a class="anchor" id="ga8c5b6259fe787815cd4317c41570a655"></a><!-- doxytag: member="apsmeRequestKey.h::APS_RequestKeyReq" ref="ga8c5b6259fe787815cd4317c41570a655" args="(APS_RequestKeyReq_t *req)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void APS_RequestKeyReq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_a_p_s___request_key_req__t.html">APS_RequestKeyReq_t</a> *&#160;</td>
          <td class="paramname"><em>req</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Request either the active network key or a new application link key. </p>
<p>See ZigBee Specification r19, 4.4.6.1, page 465.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">req</td><td>- pointer to APSME-REQUEST-KEY.request's parameters. </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="struct_a_p_s___request_key_req__t.html" title="Parameters of APSME-REQUEST-KEY.request primitive.">APS_RequestKeyReq_t</a> </dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="user"><dt><b>Response statuses:</b></dt><dd>Accessed via the <a class="el" href="struct_a_p_s___request_key_conf__t.html#af6ab86c727f30f2a65e10f96cdac6911" title="The status of requesting the key.">APS_RequestKeyConf_t::status</a> field of the <a class="el" href="struct_a_p_s___request_key_req__t.html#a4648d9edeffe0149a682d248fc8ae0d6">APS_RequestKeyReq_t::APS_RequestKeyConf</a> callback's argument. </dd></dl>

</div>
</div>
<a class="anchor" id="ga1bb21d70018271538c85d9859b8ee5b6"></a><!-- doxytag: member="apsmeSwitchKey.h::APS_SwitchKeyReq" ref="ga1bb21d70018271538c85d9859b8ee5b6" args="(APS_SwitchKeyReq_t *req)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void APS_SwitchKeyReq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_a_p_s___switch_key_req__t.html">APS_SwitchKeyReq_t</a> *&#160;</td>
          <td class="paramname"><em>req</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sends a command to a remote device to switch to another network key. </p>
<p>The command can be send by the trust center to force a specific device or all devices in the network to make another network key active. If a single node is to be affected the extended address of the node shall be specified in the <code>destAddress</code> field. To send a switch key command to all devices in the network assign <code>destAddress</code> to ::APS_BROADCAST_RX_ON_WHEN_IDLE_EXT_ADDRESS.</p>
<p>A single network key must be active on all devices in the network. Two network keys may be active on different device, while the network is switching to the new network key. In high security the command to switch the network key must be sent by the trust center separately to each device in the network (unicast). In other security modes the trust center should send a broadcast request.</p>
<p>The function conforms to a primitive defined in ZigBee Specification r19, 4.4.7.1, page 467.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">req</td><td>- pointer to APSME-SWITCH-KEY.request's parameters. </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="struct_a_p_s___switch_key_req__t.html" title="Parameters of APSME-SWITCH-KEY.request primitive.">APS_SwitchKeyReq_t</a> </dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None</dd></dl>
<dl class="user"><dt><b>Response statuses:</b></dt><dd>Accessed via the <a class="el" href="struct_a_p_s___switch_key_conf__t.html#a3ce79772968d3e944fa402a7e45e6c34">APS_SwitchKeyConf_t::status</a> field of the <a class="el" href="struct_a_p_s___switch_key_req__t.html#a469ce588aba6462207c6c1876ece8979">APS_SwitchKeyReq_t::APS_SwitchKeyConf</a> callback's argument. </dd></dl>

</div>
</div>
<a class="anchor" id="ga80e8e102dfc86765d25af1c438b2aed3"></a><!-- doxytag: member="apsmeTransportKey.h::APS_TransportKeyReq" ref="ga80e8e102dfc86765d25af1c438b2aed3" args="(APS_TransportKeyReq_t *const req)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void APS_TransportKeyReq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_a_p_s___transport_key_req__t.html">APS_TransportKeyReq_t</a> *const&#160;</td>
          <td class="paramname"><em>req</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Transfers a security key to a specified node. </p>
<p>The function is used by the stack on the trust center to transfer security keys during authentication procedures and upon receiving requests for a link key. The application can also use it, for example, to distribute a new network key. The function conforms to ZigBee Specification r19, 4.4.3.1, page 451.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">req</td><td>- a pointer to request parameters of type <a class="el" href="struct_a_p_s___transport_key_req__t.html" title="Parameters of APSME-TRANSPORT-KEY.request primitive. See ZigBee Specification r19, 4.4.3.1, page 451.">APS_TransportKeyReq_t</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="user"><dt><b>Response statuses:</b></dt><dd>Accessed via the APS_TransportKeyConf_t::status field of the <a class="el" href="struct_a_p_s___transport_key_req__t.html#a2e7bcfaa232b00755e4dc04e5d027d22">APS_TransportKeyReq_t::APS_TransportKeyConf</a> callback's argument. </dd></dl>

</div>
</div>
</div>
<hr style="border-top:1px solid #C4CFE5; margin-top:20px"/>
</body>
</html>
