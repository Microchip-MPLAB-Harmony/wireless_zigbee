<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>PIC32CX-BZ Zigbee API Reference: Hardware Abstraction Layer</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">PIC32CX-BZ Zigbee API Reference</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">Hardware Abstraction Layer </div>  </div>
</div>
<div class="contents">
<div class="textblock"><p>HAL component of the Microchip Zigbee SDK provides functions for working with common hardware interfaces such as USART, TWI, SPI, ADC, GPIO, IRQ, etc. Other interfaces supported by HAL include Application timer, System time, Watchdog, and Warm Reset. What serial interfaces are supported depends on the platform; refer to <em>AVR2050: Microchip Zigbee Developer Guide</em> for a full list of supported interfaces.</p>
<p>Note that although available in the HAL component, HAL_ReadEeprom()/HAL_WriteEeprom() and Sleep Timer functions are intended for internal use inside the stack, and applications shall avoid using them.</p>
<p><span class="table_of_contents">References</span> </p>
<ul>
<li>
<a class="el" href="group__hal__api.html">HAL functions</a> <ul>
<li>
<a class="el" href="group__hal__usart.html">USART controlling</a> </li>
<li>
<a class="el" href="group__hal__spi.html">SPI</a> </li>
<li>
<a class="el" href="group__hal__irq.html">External interrupts</a> </li>
<li>
<a class="el" href="group__hal__1wire.html">1-Wire</a> </li>
<li>
<a class="el" href="group__hal__usb.html">USB</a> </li>
<li>
<a class="el" href="group__hal__i2c.html">I2C</a> </li>
<li>
<a class="el" href="group__hal__pwm.html">PWM</a> </li>
<li>
<a class="el" href="group__hal__wdt.html">Watch Dog timer</a> </li>
<li>
<a class="el" href="group__hal__misc.html">Miscellaneous</a> </li>
</ul>
</li>
</ul>
 
<hr style="border-top:1px solid #E0E0FF; margin-top:10px"/>

<span class="table_of_contents">Contents</span>
<ul class="table_of_contents">
  <li><a href="#irq">Registering external interrupts</a></li>
  <li><a href="#timer">Application timer</a></li>
  <li>
    <a href="#uart">Exchanging data over USART/UART</a>
    <ul>
      <li><a href="#configure_usart">Configuration</a></li>
      <li><a href="#write_usart">Writing data</a></li>
      <li><a href="#read_usart">Reading data</a></li>
    </ul>
  </li>
  <li><a href="#usb">Using USB API</a></li>
</ul>
<p></p>
 <span class="to_top"><a href="#">Back to top</a></span>  <h2><a class="anchor" id="irq"></a>
Registering external interrupts</h2>
<p>To register an external interrupt call the <a class="el" href="group__hal__irq.html#ga94a2aa004acdaeacd16ab63f55421253" title="Registers the user&#39;s irqNumber external interrupt.">HAL_RegisterIrq()</a> function. In the arguments specify an IRQ number, an IRQ mode, and a pointer to the callback function, which will be called when an interrupt occurs. IRQ numbers available on different platform are given in the function specification.</p>
<p>Registering an interrupt does not enable it. To start using the registered interrupt the application shall enable it by calling the <a class="el" href="group__hal__irq.html#ga00979ab15cb4292e3ac69028b6fa46bf" title="Enables the irqNumber interrupt.">HAL_EnableIrq()</a> function with the IRQ number specified during registration as an argument.</p>
<p>In the following code sample an external interrupt is registered and enabled on pin D1 of an XMEGA microcontroller:</p>
<div class="fragment"><pre class="fragment"><span class="comment">//Callback declaration</span>
<span class="keywordtype">void</span> interruptHandler(<span class="keywordtype">void</span>);
...
HAL_RegisterIrq(IRQ_D1, <a class="code" href="irq_8h.html#a940ce4160638e7604ea3ff5aaaa9f53b" title="The low level generates an interrupt request.">IRQ_LOW_LEVEL</a>, interruptHandler);
<a class="code" href="group__hal__irq.html#ga00979ab15cb4292e3ac69028b6fa46bf" title="Enables the irqNumber interrupt.">HAL_EnableIrq</a>(IRQ_D1);
</pre></div><p>Once the IRQ is enabled, the callback function will be called each time the MCU receives a signal in the appropriate mode on the pin specified by the IRQ number. When such signal is received, the MCU stops executing the code it has been processing, passes the control to the callback function registered for the interrupt, and returns to the place where it has stopped when the callback function finishes processing.</p>
<p>An interrupt can be disabled or unregistered at any time via <a class="el" href="group__hal__irq.html#ga598859b43aafee856603b185d683e8b3" title="Disables the irqNumber interrupt.">HAL_DisableIrq()</a> and <a class="el" href="group__hal__irq.html#gaad9b3c6990836bd4e8696a9c21381021" title="Unregisters the user&#39;s irqNumber interrupt.">HAL_UnregisterIrq()</a>.</p>
 <span class="to_top"><a href="#">Back to top</a></span>  <h2><a class="anchor" id="timer"></a>
Application timer</h2>
<p>Applicaton timers can be used to schedule periodic tasks or execute specific actions after a certain delay. A timer created with Microchip Zigbee HAL API may hit only once or fire repeatedly with a given interval.</p>
<p>To start a timer call the <a class="el" href="group__hal__misc.html#gaaf0388c370b0537b94c420e2f31e0d9a" title="Starts to count an interval (starts user timer).">HAL_StartAppTimer(HAL_AppTimer_t* params)</a> function, where <code>params</code> represents function's parameters. In the parameters, specify the timer interval, timer mode (<code>TIMER_REPEAT_MODE</code> or <code>TIMER_ONE_SHOT_MODE</code>), and the callback function, which will be called each time the timer fires.</p>
<p>To stop the timer, call the <a class="el" href="group__hal__misc.html#ga9d8e56be5b1291f33083e8976806354e" title="Stops the user timer.">HAL_StopAppTimer(HAL_AppTimer_t* params)</a> with the pointer to the same instance of the ::HAL_AppTimer_t type that was used to configure the timer. This will stop a periodic timer and prevent execution of a one-shot timer if it still has not fired.</p>
<p>Consider the following example:</p>
<div class="fragment"><pre class="fragment"><span class="comment">//Callback definition</span>
<span class="keywordtype">void</span> timerFired()
{
  <span class="comment">//Do whatever you need</span>
}
<span class="comment">//Define the parameters instance in the outer scope</span>
HAL_AppTimer_t timer;
...
timer.interval = 5000; <span class="comment">//Timer interval in milliseconds</span>
timer.mode     = TIMER_REPEAT_MODE;
timer.callback = timerFired;
<a class="code" href="group__hal__misc.html#gaaf0388c370b0537b94c420e2f31e0d9a" title="Starts to count an interval (starts user timer).">HAL_StartAppTimer</a>(&amp;timer); 
</pre></div><p>When a timer fires, the MCU passes control to the callback function registered for the timer and then continues execution from the place it stopped when the timer fired.</p>
 <span class="to_top"><a href="#">Back to top</a></span>  <h2><a class="anchor" id="uart"></a>
Exchanging data over USART/UART</h2>
<p>USART/UART are among the most frequently used serial interfaces and the serial interfaces used by default in sample applications included in the SDK. HAL provides the same API for both USART and UART. Whether to use a synchronous (USART) or aynchronous (UART) interface is determined by the <code>mode</code> field of the <a class="el" href="group__hal__usart.html#ga59024175c26d131adf800e19ac6285b7" title="Registers usart&#39;s event handlers. Performs configuration of usart registers. Performs configuration o...">HAL_OpenUsart()</a> function's parameters.</p>
<h3><a class="anchor" id="configure_usart"></a>
Configuration</h3>
<p>To start using USART/UART configure an instance of the <a class="el" href="struct_h_a_l___usart_descriptor__t.html" title="Usart descriptor.">HAL_UsartDescriptor_t</a> type and call the <a class="el" href="group__hal__usart.html#ga59024175c26d131adf800e19ac6285b7" title="Registers usart&#39;s event handlers. Performs configuration of usart registers. Performs configuration o...">HAL_OpenUsart()</a> function providing it with the pointer to this instance.</p>
<p><a class="el" href="struct_h_a_l___usart_descriptor__t.html" title="Usart descriptor.">HAL_UsartDescriptor_t</a> contains fields for port configuration including channel, baudrate and some other related parameters, buffers for received and transmitted data and callbacks for indications of data reception (rx) and transmission (tx). The instance of this time must be defined in the outer scope since it will be used as an argument to identify the configured USART/UART port in read and write functions.</p>
<p>There are two modes to work with USART/UART in the application (reception and transmission of data can be configured to work in different modes):</p>
<ul>
<li><em>Callback mode</em> <br/>
 In this case the stack indicates an end of data transmission or data reception by calling the callback functions specified in <a class="el" href="group__hal__usart.html#ga59024175c26d131adf800e19ac6285b7" title="Registers usart&#39;s event handlers. Performs configuration of usart registers. Performs configuration o...">HAL_OpenUsart()</a> function's parameters. To receive data in the callback mode, set the rx callback to a not-null function's pointer and the rx buffer. To transmit data in the callback mode, set the tx buffer to <code>NULL</code>, the tx buffer length to 0, and specify the tx callback.</li>
</ul>
<ul>
<li><em>Polling mode</em> <br/>
 In this case the stack uses the tx buffer to keep transmitting data while they are being sent and the rx buffer to store received data until the application requests it. The application is not notified. To receive data in the polling mode, provide the rx buffer and set the rx callback to <code>NULL</code>. To check whether data have been received and to retrieve them, call the <a class="el" href="group__hal__usart.html#ga8c9727e028dce14b40526dff8b841b4d" title="Reads a number of bytes from usart and places them to the buffer.">HAL_ReadUsart()</a> funtion. To transmit data in the polling mode, set the tx callback to <code>NULL</code> and provide the tx buffer.</li>
</ul>
<p>The following code sample demostrates how the UART interface may be configured (to work in the callback mode), similarly to Microchip Zigbee sample applications:</p>
<div class="fragment"><pre class="fragment"><span class="comment">//Define a buffer for received data</span>
uint8_t rxBuffer[RX_BUFFER_LENGTH];

<span class="comment">//Callbacks&#39; declarations</span>
<span class="keywordtype">void</span> usartBytesReceived(uint8_t readBytesLen);
<span class="keywordtype">void</span> usartWriteConfirm(<span class="keywordtype">void</span>);

<a class="code" href="struct_h_a_l___usart_descriptor__t.html" title="Usart descriptor.">HAL_UsartDescriptor_t</a> usartDescriptor = {
  .<a class="code" href="struct_h_a_l___usart_descriptor__t.html#a2e4fb251b6c58dada1fb11b010ce3d15" title="tty - USART_CHANNEL_n to be used. &quot;n&quot; range depends on the platform. Take a look into halUsart...">tty</a>            = USART_CHANNEL;
  .mode           = USART_MODE_ASYNC;  <span class="comment">//Use asynchronous mode (UART)</span>
  .flowControl    = USART_FLOW_CONTROL_NONE;
  .baudrate       = USART_BAUDRATE_38400;
  .dataLength     = USART_DATA8;
  .parity         = USART_PARITY_NONE;
  .stopbits       = USART_STOPBIT_1;
  .rxBuffer       = rxBuffer;
  .rxBufferLength = USART_RX_BUFFER_LENGTH;
  .txBuffer       = NULL;
  .txBufferLength = 0;
  .rxCallback     = usartBytesReceived;
  .txCallback     = usartWriteConfirm;
}
...
HAL_OpenUsart(&amp;usartDescriptor);
</pre></div><h3><a class="anchor" id="write_usart"></a>
Writing data</h3>
<p>Once a USART/UART port has been opened, to send data over this port use the <a class="el" href="group__hal__usart.html#ga90edae96f61d2f25020794bbe8c1c024" title="Writes a number of bytes to usart channel. txCallback function will be used to notify when the transm...">HAL_WriteUsart()</a> function, providing it with the USART/UART descriptor, a buffer with data, and the length of data; for example:</p>
<div class="fragment"><pre class="fragment"><span class="keyword">static</span> <span class="keywordtype">char</span> msgBuffer[] = <span class="stringliteral">&quot;Message for UART&quot;</span>;
<a class="code" href="group__hal__usart.html#ga90edae96f61d2f25020794bbe8c1c024" title="Writes a number of bytes to usart channel. txCallback function will be used to notify when the transm...">HAL_WriteUsart</a>(&amp;usartDescriptor, (uint8_t*)msgBuffer, <span class="keyword">sizeof</span>(msgBuffer));
</pre></div><p>In the callback mode, the tx callback function registered via the <a class="el" href="group__hal__usart.html#ga59024175c26d131adf800e19ac6285b7" title="Registers usart&#39;s event handlers. Performs configuration of usart registers. Performs configuration o...">HAL_OpenUsart()</a> function will be called when the stack finishes transmitting the data. While data are being transmitted, the buffer cannot be reused, until the callback execution.</p>
<p>In the polling mode, the stack copies data from the buffer provided as an argument to the tx buffer specified in the descriptor, and so the buffer with data can be immediately reused. To check whether there is enough space in the tx buffer, use the <a class="el" href="group__hal__usart.html#ga2d770f76276c1086a98b14a1e4aa2e62" title="Checks the status of tx buffer.">HAL_IsTxEmpty()</a> function.</p>
<h3><a class="anchor" id="read_usart"></a>
Reading data</h3>
<p>In the callback mode, the stack calls the rx callback function specified in the USART/UART descriptor to indicate data reception. In the callback function, the application should read the received data via the <a class="el" href="group__hal__usart.html#ga8c9727e028dce14b40526dff8b841b4d" title="Reads a number of bytes from usart and places them to the buffer.">HAL_ReadUsart()</a> function. As the arguments, specify the desriptor, the buffer to save received bytes, and the number of received bytes, which is given in the argument of the callback function. See the following example:</p>
<div class="fragment"><pre class="fragment"><span class="comment">//Define a buffer for received data</span>
uint8_t usartRxBuffer[APP_USART_BUFFER_SIZE];

<span class="comment">//Callback function specified in the usart descriptor</span>
<span class="keyword">static</span> <span class="keywordtype">void</span> usartBytesReceived(uint16_t bytesToRead)
{
  <a class="code" href="group__hal__usart.html#ga8c9727e028dce14b40526dff8b841b4d" title="Reads a number of bytes from usart and places them to the buffer.">HAL_ReadUsart</a>(&amp;usartDescriptor, usartRxBuffer, bytesToRead);
  ...
}
</pre></div><p>In the polling mode, the stack does not notify the application about data reception. Received bytes are stored in the rx buffer of the USART/UART descriptor. To retrieve data the application should call the <a class="el" href="group__hal__usart.html#ga8c9727e028dce14b40526dff8b841b4d" title="Reads a number of bytes from usart and places them to the buffer.">HAL_ReadUsart()</a> function specifying the amount of bytes it wishes to read. A value returned by the function indicates how much bytes have been actually copied to the buffer.</p>
<h2><a class="anchor" id="usb"></a>
Using USB API</h2>
<p>The HAL component's USB API may be used to implement a certain Universal Serial Bus class, in the same way as it is used inside the stack to implement Mass Storage device and DFU device. Note that this USB API cannot be used to implement a USB host controller.</p>
<p>Details on the USB protocol and related terms may be found in the USB specification. When a USB device joins a USB network (having tiered-star topology) it communicates with the host, perhaps through a series of hubs. But the initiator of all transactions is always the host.</p>
<p>The first function to be called is HAL_UsbInit(), which initializes the USB component. A USB device may register a number of handlers to process various commands received from the host.</p>
<p>The HAL_RegisterEndOfBusResetHandler() function registers the first invoked handler. The handler indicates that the host finished reseting the bus and the USB device itself - operation performed by the host at the beginning of interaction with aby USB device.</p>
<p>The HAL_RegisterRequestHandler() function registers a handler that will process requests received from the host. A request may command the USB device to send a specific descriptor, to set a specific configuration (a USB device may have several different configurations - with different sets of endpoints), or to set the address also received from the host. Upon processing set configuration request the USB device should configure endpoints, if not yet configured, using the HAL_ConfigureEndpoint() function.</p>
<p>Data are sent or received from the bus, using HAL_UsbRead() and HAL_UsbWrite() functions. However, data will be read or written only when the host starts the corresponding transaction. Note that the HAL_UsbRead() function is used for all data transfers to the host, including sending descriptors. </p>
</div></div>
<hr style="border-top:1px solid #C4CFE5; margin-top:20px"/>
</body>
</html>
