<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>PIC32CX-BZ Zigbee API Reference: isdImageStorage.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">PIC32CX-BZ Zigbee API Reference</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
</div>
<div class="header">
  <div class="summary">
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">isdImageStorage.h File Reference</div>  </div>
</div>
<div class="contents">

<p>The public API of the image storage driver.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;<a class="el" href="sys_types_8h_source.html">sysTypes.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="zcl_o_t_a_u_cluster_8h_source.html">zclOTAUCluster.h</a>&gt;</code><br/>
<code>#include &lt;<a class="el" href="usb_8h_source.html">usb.h</a>&gt;</code><br/>
</div>
<p><a href="isd_image_storage_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9208f2f15c1bf15b60b4fe330847e939"></a><!-- doxytag: member="isdImageStorage.h::IsdOpenCb_t" ref="a9208f2f15c1bf15b60b4fe330847e939" args=")(ISD_Status_t)" -->
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><b>IsdOpenCb_t</b> )(<a class="el" href="isd_image_storage_8h.html#af1f10d691d46d2756625fc942ea72695">ISD_Status_t</a>)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afa5914829d34354c89c3e80482a81118"></a><!-- doxytag: member="isdImageStorage.h::IsdQueryNextImageCb_t" ref="afa5914829d34354c89c3e80482a81118" args=")(ZCL_OtauQueryNextImageResp_t *)" -->
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><b>IsdQueryNextImageCb_t</b> )(<a class="el" href="struct_z_c_l___otau_query_next_image_resp__t.html">ZCL_OtauQueryNextImageResp_t</a> *)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2706f4b6b577ae67fd377c9882fceefd"></a><!-- doxytag: member="isdImageStorage.h::IsdImageBlockCb_t" ref="a2706f4b6b577ae67fd377c9882fceefd" args=")(ZCL_OtauImageBlockResp_t *)" -->
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><b>IsdImageBlockCb_t</b> )(<a class="el" href="struct_z_c_l___otau_image_block_resp__t.html">ZCL_OtauImageBlockResp_t</a> *)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3fab800475dc7cd659514960c543afca"></a><!-- doxytag: member="isdImageStorage.h::IsdUpgradeEndCb_t" ref="a3fab800475dc7cd659514960c543afca" args=")(ZCL_OtauUpgradeEndResp_t *)" -->
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><b>IsdUpgradeEndCb_t</b> )(<a class="el" href="struct_z_c_l___otau_upgrade_end_resp__t.html">ZCL_OtauUpgradeEndResp_t</a> *)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6dd72ce6ca3ac50c7002ea9a5de666e3"></a><!-- doxytag: member="isdImageStorage.h::ISD_TunnelDescriptor_t" ref="a6dd72ce6ca3ac50c7002ea9a5de666e3" args="" -->
typedef HAL_UsbHWDescriptor_t&#160;</td><td class="memItemRight" valign="bottom"><b>ISD_TunnelDescriptor_t</b></td></tr>
<tr><td colspan="2"><h2><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="isd_image_storage_8h.html#af1f10d691d46d2756625fc942ea72695">ISD_Status_t</a> { <br/>
&#160;&#160;<b>ISD_NO_COMMUNICATION</b>, 
<br/>
&#160;&#160;<b>ISD_COMMUNICATION_ESTABLISHED</b>, 
<br/>
&#160;&#160;<b>ISD_IDLE</b>, 
<br/>
&#160;&#160;<b>ISD_BUSY</b>, 
<br/>
&#160;&#160;<b>ISD_HARDWARE_FAULT</b>
<br/>
 }</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Statuses returned by the driver. <br/></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="isd_image_storage_8h.html#a5e5a6ac6cf4f9891870eedff9a72e97c">ISD_Open</a> (IsdOpenCb_t cb)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Opens the serial interface for connection with the image storage.  <a href="#a5e5a6ac6cf4f9891870eedff9a72e97c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a60dd9264ce39d8e26ea4b434db07eff4"></a><!-- doxytag: member="isdImageStorage.h::ISD_Close" ref="a60dd9264ce39d8e26ea4b434db07eff4" args="(void)" -->
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="isd_image_storage_8h.html#a60dd9264ce39d8e26ea4b434db07eff4">ISD_Close</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Closes the serial interface opened using <a class="el" href="isd_image_storage_8h.html#a5e5a6ac6cf4f9891870eedff9a72e97c" title="Opens the serial interface for connection with the image storage.">ISD_Open()</a> <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="isd_image_storage_8h.html#a7a05cfc8240f091c24d956e5e81514a1">ISD_QueryNextImageReq</a> (<a class="el" href="struct_z_c_l___addressing__t.html">ZCL_Addressing_t</a> *addressing, <a class="el" href="struct_z_c_l___otau_query_next_image_req__t.html">ZCL_OtauQueryNextImageReq_t</a> *data, IsdQueryNextImageCb_t cb)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends a query next image request to the storage system, which should decide whether the request's issuer needs a new image.  <a href="#a7a05cfc8240f091c24d956e5e81514a1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="isd_image_storage_8h.html#a128149b925620aaebf07d32cf81b31d2">ISD_ImageBlockReq</a> (<a class="el" href="struct_z_c_l___addressing__t.html">ZCL_Addressing_t</a> *addressing, <a class="el" href="struct_z_c_l___otau_image_block_req__t.html">ZCL_OtauImageBlockReq_t</a> *data, IsdImageBlockCb_t cb)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends an image block request to the storage system, in order to retrieve a certain block of data of the specified image.  <a href="#a128149b925620aaebf07d32cf81b31d2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="isd_image_storage_8h.html#afdfe331e964aa4e5d482e84ca670783c">ISD_UpgradeEndReq</a> (<a class="el" href="struct_z_c_l___addressing__t.html">ZCL_Addressing_t</a> *addressing, <a class="el" href="struct_z_c_l___otau_upgrade_end_req__t.html">ZCL_OtauUpgradeEndReq_t</a> *data, IsdUpgradeEndCb_t cb)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends an upgrade end request to the storage system, notifying it that all blocks have been received.  <a href="#afdfe331e964aa4e5d482e84ca670783c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="isd_image_storage_8h.html#a0fdb3befccc8bcb521efb9defe32a06c">ISD_OpenTunnel</a> (ISD_TunnelDescriptor_t *descriptor)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize ISD tunnel.  <a href="#a0fdb3befccc8bcb521efb9defe32a06c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="isd_image_storage_8h.html#a18fc089dfd6832bcce20c773e5e6d700">ISD_CloseTunnel</a> (ISD_TunnelDescriptor_t *descriptor)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Close ISD tunnel.  <a href="#a18fc089dfd6832bcce20c773e5e6d700"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="isd_image_storage_8h.html#ab1399954547da9b94d66952237e83044">ISD_ReadTunnel</a> (ISD_TunnelDescriptor_t *descriptor, uint8_t *buffer, uint16_t length)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Read contents from ISD tunnel to buffer.  <a href="#ab1399954547da9b94d66952237e83044"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="isd_image_storage_8h.html#a2e7a967999da16e7062d7eaa5dee9ebe">ISD_WriteTunnel</a> (ISD_TunnelDescriptor_t *descriptor, uint8_t *buffer, uint16_t length)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Send contents of buffer over USART through ISD tunnel.  <a href="#a2e7a967999da16e7062d7eaa5dee9ebe"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="isd_image_storage_8h.html#ae00f493648dede2a13b4acf3425fecf1">ISD_GetTotalImageSize</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the total size of the image to be upgraded.  <a href="#ae00f493648dede2a13b4acf3425fecf1"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>The public API of the image storage driver. </p>
<p>The image storage driver (ISD) uses commands equivalent to the OTAU cluster's commands sent from the OTAU client to the OTAU server while transferring an image. In fact, the OTAU server uses ISD only to pass OTAU client's commands to the image storage system.</p>
<dl class="author"><dt><b>Author:</b></dt><dd>Microchip Corporation: <a href="http://www.microchip.com">http://www.microchip.com</a> <br/>
 Support email: <a href="mailto:support@microchip.com">support@microchip.com</a></dd></dl>
<p>Copyright (c) 2018, Microchip Corporation. All rights reserved. Licensed under Mirochip's Limited License Agreement. </p>

<p>Definition in file <a class="el" href="isd_image_storage_8h_source.html">isdImageStorage.h</a>.</p>
</div><hr/><h2>Function Documentation</h2>
<a class="anchor" id="a5e5a6ac6cf4f9891870eedff9a72e97c"></a><!-- doxytag: member="isdImageStorage.h::ISD_Open" ref="a5e5a6ac6cf4f9891870eedff9a72e97c" args="(IsdOpenCb_t cb)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ISD_Open </td>
          <td>(</td>
          <td class="paramtype">IsdOpenCb_t&#160;</td>
          <td class="paramname"><em>cb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Opens the serial interface for connection with the image storage. </p>
<p>The serial interface captured by executing this function may not be used until <a class="el" href="ofd_ext_memory_8h.html#ac6067c5f2ebb87d6b84790ab2f054d63" title="Closes the serial interface opened using OFD_Open()">OFD_Close()</a> is called.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cb</td><td>- pointer to a callback function called once the interface is opened; can be set to NULL </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a7a05cfc8240f091c24d956e5e81514a1"></a><!-- doxytag: member="isdImageStorage.h::ISD_QueryNextImageReq" ref="a7a05cfc8240f091c24d956e5e81514a1" args="(ZCL_Addressing_t *addressing, ZCL_OtauQueryNextImageReq_t *data, IsdQueryNextImageCb_t cb)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ISD_QueryNextImageReq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_z_c_l___addressing__t.html">ZCL_Addressing_t</a> *&#160;</td>
          <td class="paramname"><em>addressing</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_z_c_l___otau_query_next_image_req__t.html">ZCL_OtauQueryNextImageReq_t</a> *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IsdQueryNextImageCb_t&#160;</td>
          <td class="paramname"><em>cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sends a query next image request to the storage system, which should decide whether the request's issuer needs a new image. </p>
<p>The response to this command received from the storage system should be somehow delivered to the client. If the storage system decides that the client needs a new image the client may then start sending image block requests to retrieve individual blocks of the new image.</p>
<p>Whether the client device should download a new image is indicated by the <code>status</code> field of the callback's argument (which is of <a class="el" href="struct_z_c_l___otau_query_next_image_resp__t.html" title="Query Next Image Response Command.">ZCL_OtauQueryNextImageResp_t</a> type) having the <a class="el" href="zcl_8h.html#ad5ed4e48a062501fc4f9a9378cffe0daa1f525bf63960effa3a2b01b20e744e94" title="Operation was successful.">ZCL_SUCCESS_STATUS</a> value.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">addressing</td><td>- pointer to structure that contains network information about the client including network address, endpoint, cluster ID and profile ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>- data payload containing information about client's firmware </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb</td><td>- pointer to a callback function called when the response is received from the storage system; can be set to NULL </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a128149b925620aaebf07d32cf81b31d2"></a><!-- doxytag: member="isdImageStorage.h::ISD_ImageBlockReq" ref="a128149b925620aaebf07d32cf81b31d2" args="(ZCL_Addressing_t *addressing, ZCL_OtauImageBlockReq_t *data, IsdImageBlockCb_t cb)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ISD_ImageBlockReq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_z_c_l___addressing__t.html">ZCL_Addressing_t</a> *&#160;</td>
          <td class="paramname"><em>addressing</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_z_c_l___otau_image_block_req__t.html">ZCL_OtauImageBlockReq_t</a> *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IsdImageBlockCb_t&#160;</td>
          <td class="paramname"><em>cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sends an image block request to the storage system, in order to retrieve a certain block of data of the specified image. </p>
<p>The function requests an individual block (specified by the offset inside the image and having the OFD_BLOCK_SIZE length) of the specific image from the storage system. The image is specified by its image type, manufacturer ID and firmware version.</p>
<p>The storage system replies with the response comman containing the requested data (if all information is correct). Response reception is indicated by the callback function.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">addressing</td><td>- pointer to the structure that contains network information about the client including network address, endpoint, cluster ID and profile ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>- data payload containing information about the requested block of data and the image </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb</td><td>- pointer to a callback function called when the response is received from the storage system; can be set to NULL </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afdfe331e964aa4e5d482e84ca670783c"></a><!-- doxytag: member="isdImageStorage.h::ISD_UpgradeEndReq" ref="afdfe331e964aa4e5d482e84ca670783c" args="(ZCL_Addressing_t *addressing, ZCL_OtauUpgradeEndReq_t *data, IsdUpgradeEndCb_t cb)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ISD_UpgradeEndReq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_z_c_l___addressing__t.html">ZCL_Addressing_t</a> *&#160;</td>
          <td class="paramname"><em>addressing</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_z_c_l___otau_upgrade_end_req__t.html">ZCL_OtauUpgradeEndReq_t</a> *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IsdUpgradeEndCb_t&#160;</td>
          <td class="paramname"><em>cb</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sends an upgrade end request to the storage system, notifying it that all blocks have been received. </p>
<p>The function notifies the storage system that the client has received the whole image. The storage system replies with the update end response that specifies the time after which the client should switch to the new image.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">addressing</td><td>- pointer to the structure that contains network information about the client including network address, endpoint, cluster ID and profile ID </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>- data payload containg information about the image that has been downloaded to the client </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cb</td><td>- pointer to a callback function called when the response is received from the storage system; can be set to NULL </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0fdb3befccc8bcb521efb9defe32a06c"></a><!-- doxytag: member="isdImageStorage.h::ISD_OpenTunnel" ref="a0fdb3befccc8bcb521efb9defe32a06c" args="(ISD_TunnelDescriptor_t *descriptor)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ISD_OpenTunnel </td>
          <td>(</td>
          <td class="paramtype">ISD_TunnelDescriptor_t *&#160;</td>
          <td class="paramname"><em>descriptor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initialize ISD tunnel. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">descriptor</td><td>- pointer to USART descriptor</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>zero value if tunnel was initialized, false otherwise. </dd></dl>

</div>
</div>
<a class="anchor" id="a18fc089dfd6832bcce20c773e5e6d700"></a><!-- doxytag: member="isdImageStorage.h::ISD_CloseTunnel" ref="a18fc089dfd6832bcce20c773e5e6d700" args="(ISD_TunnelDescriptor_t *descriptor)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ISD_CloseTunnel </td>
          <td>(</td>
          <td class="paramtype">ISD_TunnelDescriptor_t *&#160;</td>
          <td class="paramname"><em>descriptor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Close ISD tunnel. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">descriptor</td><td>- pointer to USART descriptor</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>always zero. (to be correspond public API). </dd></dl>

</div>
</div>
<a class="anchor" id="ab1399954547da9b94d66952237e83044"></a><!-- doxytag: member="isdImageStorage.h::ISD_ReadTunnel" ref="ab1399954547da9b94d66952237e83044" args="(ISD_TunnelDescriptor_t *descriptor, uint8_t *buffer, uint16_t length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ISD_ReadTunnel </td>
          <td>(</td>
          <td class="paramtype">ISD_TunnelDescriptor_t *&#160;</td>
          <td class="paramname"><em>descriptor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Read contents from ISD tunnel to buffer. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">descriptor</td><td>- pointer to USART descriptor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>- pointer to destination buffer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>- buffer length</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>number of read bytes or -1 if error </dd></dl>

</div>
</div>
<a class="anchor" id="a2e7a967999da16e7062d7eaa5dee9ebe"></a><!-- doxytag: member="isdImageStorage.h::ISD_WriteTunnel" ref="a2e7a967999da16e7062d7eaa5dee9ebe" args="(ISD_TunnelDescriptor_t *descriptor, uint8_t *buffer, uint16_t length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int ISD_WriteTunnel </td>
          <td>(</td>
          <td class="paramtype">ISD_TunnelDescriptor_t *&#160;</td>
          <td class="paramname"><em>descriptor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Send contents of buffer over USART through ISD tunnel. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">descriptor</td><td>- pointer to USART descriptor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>- buffer to be sent </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>- buffer length</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>number of sent bytes or -1 if error </dd></dl>

</div>
</div>
<a class="anchor" id="ae00f493648dede2a13b4acf3425fecf1"></a><!-- doxytag: member="isdImageStorage.h::ISD_GetTotalImageSize" ref="ae00f493648dede2a13b4acf3425fecf1" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t ISD_GetTotalImageSize </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Returns the total size of the image to be upgraded. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Total size of the image to be upgraded </dd></dl>

</div>
</div>
</div>
<hr style="border-top:1px solid #C4CFE5; margin-top:20px"/>
</body>
</html>
