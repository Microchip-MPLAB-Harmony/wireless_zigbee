<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>PIC32CX-BZ Zigbee API Reference: Data related functions</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">PIC32CX-BZ Zigbee API Reference</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
</div>
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Data related functions</div>  </div>
<div class="ingroups"><a class="el" href="group__aps.html">APS functions</a></div></div>
<div class="contents">

<p>APS functions related to data exchange, binding and grouping of devices.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__aps__data.html#ga2a584bc786c377e3e69b0896b0d0a55f">APS_DataReq</a> (<a class="el" href="struct_a_p_s___data_req__t.html">APS_DataReq_t</a> *const req)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends data to a node in the network.  <a href="#ga2a584bc786c377e3e69b0896b0d0a55f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__aps__data.html#gabf17ee393a76dd7e3e0ed99956e28c61">APS_CalculateTimes</a> (void)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Recalculates transmission timeouts and duplicate rejection time. Reads maximum frame transmission time, indirect poll rate and other parameters from the config server and updates ack time.  <a href="#gabf17ee393a76dd7e3e0ed99956e28c61"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__aps__data.html#gad5e605753e1707e9caecb218e6cb4a7b">APS_RegisterEndpointReq</a> (<a class="el" href="struct_a_p_s___register_endpoint_req__t.html">APS_RegisterEndpointReq_t</a> *const req)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Registers a new endpoint in the APS layer.  <a href="#gad5e605753e1707e9caecb218e6cb4a7b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__aps__data.html#ga36d0e55efedd5c7e391ddce10695afa8">APS_UnregisterEndpointReq</a> (<a class="el" href="struct_a_p_s___unregister_endpoint_req__t.html">APS_UnregisterEndpointReq_t</a> *const req)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Unregisters an endpoint from the APS layer.  <a href="#ga36d0e55efedd5c7e391ddce10695afa8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_a_p_s___register_endpoint_req__t.html">APS_RegisterEndpointReq_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__aps__data.html#ga37c9fc2e3eceef1f27559ab5efa69c87">APS_NextEndpoint</a> (const <a class="el" href="struct_a_p_s___register_endpoint_req__t.html">APS_RegisterEndpointReq_t</a> *const prev)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get next registered endpoint descriptor by previous.  <a href="#ga37c9fc2e3eceef1f27559ab5efa69c87"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__aps__data.html#ga72972ae4e955a5f249aa64e23a5b0f79">APS_StopEndpointIndication</a> (const <a class="el" href="app_framework_8h.html#a2b4bc3df040a6181a3665c8e5ab24142">Endpoint_t</a> endpoint)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Stops APS Data indications of specific endpoint number.  <a href="#ga72972ae4e955a5f249aa64e23a5b0f79"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__aps__data.html#gaccb3b92dde84e5918cd777ed6837daec">APS_ResumeEndpointIndication</a> (const <a class="el" href="app_framework_8h.html#a2b4bc3df040a6181a3665c8e5ab24142">Endpoint_t</a> endpoint)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Resumes APS Data indications of specific endpoint number.  <a href="#gaccb3b92dde84e5918cd777ed6837daec"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__aps__data.html#ga00f4be3114dfcee6e2a6409b19adf6fb">APS_BindReq</a> (<a class="el" href="struct_a_p_s___bind_req__t.html">APS_BindReq_t</a> *const req)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind to a remote device or a group.  <a href="#ga00f4be3114dfcee6e2a6409b19adf6fb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__aps__data.html#gab418bf268ff652a18f4a2c0c89a18504">APS_UnbindReq</a> (<a class="el" href="struct_a_p_s___unbind_req__t.html">APS_UnbindReq_t</a> *const req)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Unbind device from a group or from other device.  <a href="#gab418bf268ff652a18f4a2c0c89a18504"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__aps__data.html#ga2215898e304af0bcd4e9df5f34c15363">APS_DeactivateBindRecords</a> (const <a class="el" href="mac_addr_8h.html#a5b2913b1523fd1ce0a399c4fb047cc8b">ExtAddr_t</a> *const dstAddr)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Deactivates all records in the binding table that contain dstAddr as the destination address in a binding entry.  <a href="#ga2215898e304af0bcd4e9df5f34c15363"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__aps__data.html#ga3e47e895602ee6cd05c8bbeebbc8d833">APS_ActivateBindRecords</a> (const <a class="el" href="mac_addr_8h.html#a5b2913b1523fd1ce0a399c4fb047cc8b">ExtAddr_t</a> *const dstAddr)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Activates all records in the binding table that contain dstAddr as the destination address in a binding entry.  <a href="#ga3e47e895602ee6cd05c8bbeebbc8d833"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_aps_binding_entry__t.html">ApsBindingEntry_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__aps__data.html#ga0a8ea1dab11d0956e9145e60a672935f">APS_NextBindingEntry</a> (<a class="el" href="struct_aps_binding_entry__t.html">ApsBindingEntry_t</a> *entry)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a next binding entry.  <a href="#ga0a8ea1dab11d0956e9145e60a672935f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__aps__data.html#ga64bb9bf327968a882d9c81f0cbc67f5a">APS_AddGroupReq</a> (<a class="el" href="struct_a_p_s___add_group_req__t.html">APS_AddGroupReq_t</a> *const req)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the current device to the members of a certain group.  <a href="#ga64bb9bf327968a882d9c81f0cbc67f5a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__aps__data.html#ga1817dc1d30b3634608cbab0b14c4819c">APS_RemoveGroupReq</a> (<a class="el" href="struct_a_p_s___remove_group_req__t.html">APS_RemoveGroupReq_t</a> *const req)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the current device from the members of a certain group.  <a href="#ga1817dc1d30b3634608cbab0b14c4819c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__aps__data.html#gabffb03739264507fe711c79c38a2cb43">APS_RemoveAllGroupsReq</a> (<a class="el" href="struct_a_p_s___remove_all_groups_req__t.html">APS_RemoveAllGroupsReq_t</a> *const req)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the current device from the members of all groups for which a given endpoint if registered.  <a href="#gabffb03739264507fe711c79c38a2cb43"></a><br/></td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<p>APS functions related to data exchange, binding and grouping of devices. </p>
<p>Some functions that are not intended to be used by the application but internally by the stack only are not listed.</p>
<p>See more information on API usage with code examples on <a class="el" href="aps_usage.html">Using the APS component</a>. </p>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga2a584bc786c377e3e69b0896b0d0a55f"></a><!-- doxytag: member="apsdeData.h::APS_DataReq" ref="ga2a584bc786c377e3e69b0896b0d0a55f" args="(APS_DataReq_t *const req)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void APS_DataReq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_a_p_s___data_req__t.html">APS_DataReq_t</a> *const&#160;</td>
          <td class="paramname"><em>req</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sends data to a node in the network. </p>
<p>The function is used to transmit data across the network. The function is able to send a data frame to a single node (unicast), an arbitrary group of nodes (multicast), or to all nodes in the network (broadcast). Sending data to devices that support a specific cluster and to which the node has already bound is also possible. Specific actions performed by the request depend on parameters configuration. A destination type is identified according the value of <a class="el" href="struct_a_p_s___data_req__t.html#acf9d887c5027cc63f2328661bfe5f532">APS_DataReq_t::dstAddrMode</a>.</p>
<p>To send a unicast message to a node with a known short address set <a class="el" href="aps_common_8h.html#a0bc5b23d1c85adcef057f8c04dfc5365ae7b258974e64c3310ce05109e944f308">APS_SHORT_ADDRESS</a> as addressing mode, specify the destination address, destination and source endpoints, profile and cluster IDs. Specified cluster should be supported by both the destination and the originator enpoints. Both endpoints should also have the same profile ID. If the short address is unknown <a class="el" href="aps_common_8h.html#a0bc5b23d1c85adcef057f8c04dfc5365a5c4534edda395953500e62e45f1b51de">APS_EXT_ADDRESS</a> mode can be used to identify the destination with a help of extended address (<code>dstAddress.extAddress</code> field). For broadcasting exactly the same parameters should be set, but the destination address (<code>dstAddress.shortAddress</code>) should be assigned to <a class="el" href="nwk_common_8h.html#aea30e2107b74c7ed585468c42b8d2cff">BROADCAST_ADDR_ALL</a> to send a message to all nodes in the network, <a class="el" href="nwk_common_8h.html#a1e4c548440d5887fb59843b5c7dd40fd">BROADCAST_ADDR_RX_ON_WHEN_IDLE</a> to send a message to all nodes with <code>rxOnWhenIdle</code> parameter equal to 1, or <a class="el" href="nwk_common_8h.html#a1f6c1e8526b259dee79aa23eb124df22">BROADCAST_ADDR_ROUTERS</a> to send data to all routers.</p>
<p>To send data to all members of a group set <a class="el" href="aps_common_8h.html#a0bc5b23d1c85adcef057f8c04dfc5365ae7d06d84db475a76cfb47e96347c8505">APS_GROUP_ADDRESS</a> as addressing mode, and specify 16bit group address (via <code>dstAddress.groupAddress</code>). Destination endpoint should be assigned to 0xFF value. The data will be delivered to all endpoints associated to a given group address on each group member. To apply binding use <a class="el" href="aps_common_8h.html#a0bc5b23d1c85adcef057f8c04dfc5365a0d86b2a778d6ff80a43cb246fe4732c2">APS_NO_ADDRESS</a> mode and specify source endpoint and cluster ID. Other parameters such as profile, destination address and endpoint are ignored.</p>
<p>Actual data to be sent with a request is provided through <a class="el" href="struct_a_p_s___data_req__t.html#a196dc99b4a0bfea6ca3ad9871ff05c64">APS_DataReq_t::asdu</a>. The parameter takes as an argument a pointer to a segment of memory within a specially defined structure. Consider the example:</p>
<div class="fragment"><pre class="fragment"><span class="comment">// Application message buffer</span>
BEGIN_PACK
<span class="keyword">typedef</span> <span class="keyword">struct</span>
{
  uint8_t header[<a class="code" href="aps_common_8h.html#aced3428fa1b564c0995349a95d756133">APS_ASDU_OFFSET</a>]; <span class="comment">// Header</span>
  uint8_t data[APP_ASDU_SIZE]; <span class="comment">// Application data</span>
  uint8_t footer[<a class="code" href="aps_common_8h.html#a1cf798a2f6651855a2e70cdd1f727540">APS_AFFIX_LENGTH</a> - <a class="code" href="aps_common_8h.html#aced3428fa1b564c0995349a95d756133">APS_ASDU_OFFSET</a>]; <span class="comment">//Footer</span>
} PACK AppMessageBuffer_t; END_PACK
<span class="keyword">static</span> AppMessageBuffer_t appMessageBuffer; <span class="comment">// A global variable for the message buffer</span>
<span class="keyword">static</span> <a class="code" href="struct_a_p_s___data_req__t.html" title="The structure for request parameters of APS_DataReq() function.">APS_DataReq_t</a> dataReq; <span class="comment">// A global variable for the data request</span>
...
dataReq.<a class="code" href="struct_a_p_s___data_req__t.html#a196dc99b4a0bfea6ca3ad9871ff05c64">asdu</a> = appMessageBuffer.data;
dataReq.<a class="code" href="struct_a_p_s___data_req__t.html#ac3c1cc5c8134f4fe663aeefc58d98f68">asduLength</a> = <span class="keyword">sizeof</span>(appMessageBuffer.data);
</pre></div><p>Additional options are switched on and off with a help of <a class="el" href="struct_a_p_s___data_req__t.html#a329f813de89d84c93887e0a42959d02f">APS_DataReq_t::txOptions</a> parameter. For unicast messages the application can request for acknowledgement and apply fragmentation if it needs to sends greater amounts of data within a single request. Security is also may be turned and off.</p>
<p>The result of the operation is reported via callback call with confirm (<a class="el" href="struct_a_p_s___data_conf__t.html" title="The structure for reporting the result of APS_DataReq() function.">APS_DataConf_t</a>) primitive pointer as an argument. In case of acknowledged transmission the callback is called after the response from the destination node is received. When one of destination nodes receives data, it fires data indication callback on the destination endpoint.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">req</td><td>- The APSDE-DATA.request primitive pointer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="struct_a_p_s___data_req__t.html" title="The structure for request parameters of APS_DataReq() function.">APS_DataReq_t</a></dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None</dd></dl>
<p><a class="anchor" id="DataReqStatuses"></a> </p>
<dl class="user"><dt><b>Response statuses:</b></dt><dd>Accessed via the <a class="el" href="struct_a_p_s___data_conf__t.html#a48f9122abdd3a15e01ebde40c26f592e">APS_DataConf_t::status</a> field of the <a class="el" href="struct_a_p_s___data_req__t.html#a008411aa3c3ab38f4646c976b7163f3b">APS_DataReq_t::APS_DataConf</a> callback's argument <br/>
<br/>
 <a class="el" href="aps_common_8h.html#a1b4ff3a412400f1920d4d56e771230c8a0787d3e34ec427cb7d3107395f348538">APS_SUCCESS_STATUS</a> (0x00) - indicates successful transmission and delivery (if acknowledgement has been requested) of the frame <br/>
 <a class="el" href="aps_common_8h.html#a1b4ff3a412400f1920d4d56e771230c8a47d2ecca7d87082b977399f53e439421">APS_NO_SHORT_ADDRESS_STATUS</a> (0xA9) - the extended addressing mode is used, and the short address corresponding to the provided extended address has not been found <br/>
 <a class="el" href="aps_common_8h.html#a1b4ff3a412400f1920d4d56e771230c8ace0fa37248538290169a8aea8025a90e">APS_NO_BOUND_DEVICE_STATUS</a> (0xA8) - the no address addressing mode is used, and no bound devices conforming to the request have been found <br/>
 <a class="el" href="aps_common_8h.html#a1b4ff3a412400f1920d4d56e771230c8a845d3adcfa329b54e1f5f3de3a6e04f7">APS_SECURITY_FAIL_STATUS</a> (0xAD) - the link key for encryption has not been found; or the extended address of the destination device is unknown (and hence the link key cannot be located); or encryption of the APS payload via a network key is requested, but the network key is not activated; or a broadcast frame or a multicast frame is attempted to be sent with the APS payload encrypted with a link key <br/>
 <a class="el" href="aps_common_8h.html#a1b4ff3a412400f1920d4d56e771230c8ad90b01ddc295744a0e2396061f2fd42c">APS_NO_ACK_STATUS</a> (0xA7) - no acknowledgement has been received (if acknowledgement was requested) <br/>
 <a class="el" href="aps_common_8h.html#a1b4ff3a412400f1920d4d56e771230c8a19b4bd868f44e30e5d8c2832a9b10a12">APS_ASDU_TOO_LONG_STATUS</a> (0xA0) - the request can not be sent, because the payload (ASDU) is to long, and fragmentation is not supported <br/>
 <a class="el" href="aps_common_8h.html#a1b4ff3a412400f1920d4d56e771230c8a862dced50276200ed041b479e9e960b9">APS_ILLEGAL_REQUEST_STATUS</a> (0xA3) - APS is being stopped or reset - in such states when execution of a data request is impossible <br/>
 <a class="el" href="aps_common_8h.html#a1b4ff3a412400f1920d4d56e771230c8a1dc5305fe9c2df890517de8c0c0a6b45">APS_NWK_INVALID_REQUEST_STATUS</a> (0xC2) - invalid parameters have been provided, or sending a frame is impossible, because the node has not yet started the network or has lost connection to the network <br/>
 <a class="el" href="aps_common_8h.html#a1b4ff3a412400f1920d4d56e771230c8a7c59db416241b91479a50d34a3ef9624">APS_NWK_MAX_FRM_COUNTER_STATUS</a> (0xCC) - the frame counter (the number of encryptions performed by the NWK layer) reached its maximum value; rebuilding the network may be needed <br/>
 <a class="el" href="aps_common_8h.html#a1b4ff3a412400f1920d4d56e771230c8a2f57ed6c67745084cfc88daf59b54307">APS_NWK_BAD_CCM_OUTPUT_STATUS</a> (0xCE) - an error occured while encrypting or decrypting the frame, possibly for memory corruption of hardware related error <br/>
 <a class="el" href="aps_common_8h.html#a1b4ff3a412400f1920d4d56e771230c8a343c6f174645b2da6dbf90b43286ef52">APS_NWK_ROUTE_ERROR_STATUS</a> (0xD1) - the route to the destination is unknown and route discovery for this frame is prohibited <br/>
 <a class="el" href="aps_common_8h.html#a1b4ff3a412400f1920d4d56e771230c8a514d773e0f596d057485c844c45c2d00">APS_NWK_ROUTE_DISCOVERY_FAILED_STATUS</a> (0xD0) - no routes have been found for the provided destination during route discovery procedure <br/>
 <a class="el" href="aps_common_8h.html#a1b4ff3a412400f1920d4d56e771230c8ae98cec71fae19eadbffc7e57db2a3f20">APS_MAC_NO_ACK_STATUS</a> (0xE9) - transmission to the first hop failed, because MAC has not received the ack frame from the neighbor <br/>
 <a class="el" href="aps_common_8h.html#a1b4ff3a412400f1920d4d56e771230c8a4bab0ab921ecd17c30696bcc4823e5b6">APS_MAC_TRANSACTION_EXPIRED_STATUS</a> (0xF0) - the parent node, sending the frame, failed to transmit the frame to its sleeping child node, because the child node has not sent a poll request to retrieve the frame from the parent in time <br/>
 </dd></dl>

</div>
</div>
<a class="anchor" id="gabf17ee393a76dd7e3e0ed99956e28c61"></a><!-- doxytag: member="apsdeData.h::APS_CalculateTimes" ref="gabf17ee393a76dd7e3e0ed99956e28c61" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void APS_CalculateTimes </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Recalculates transmission timeouts and duplicate rejection time. Reads maximum frame transmission time, indirect poll rate and other parameters from the config server and updates ack time. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>none </dd></dl>

</div>
</div>
<a class="anchor" id="gad5e605753e1707e9caecb218e6cb4a7b"></a><!-- doxytag: member="apsdeEndpoint.h::APS_RegisterEndpointReq" ref="gad5e605753e1707e9caecb218e6cb4a7b" args="(APS_RegisterEndpointReq_t *const req)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void APS_RegisterEndpointReq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_a_p_s___register_endpoint_req__t.html">APS_RegisterEndpointReq_t</a> *const&#160;</td>
          <td class="paramname"><em>req</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Registers a new endpoint in the APS layer. </p>
<p>The function is used to register an application endpoint. In order to take part in network communication the application on the device must register at least one endpoint, since data exchange on the application level occurs between two endpoints registered on two nodes, which in fact can be a single node as well.</p>
<p>The function call is done synchronously. The function simply writes an entry containing endpoint information to a dedicated internal structure. The request parameters for the funciton include simple descriptor configuration, a pointer to the indication callback function, which is to be called upon data reception addressed to the endpoint, and a status field, which is written by the stack.</p>
<p>See the example of request parameters configuration and function usage: </p>
<div class="fragment"><pre class="fragment"><span class="comment">//Global definitions</span>
<span class="keyword">static</span> <a class="code" href="app_framework_8h.html#a6de6a020fadabae5228d009b790063b3" title="The type for holding cluster ID.">ClusterId_t</a> clustersTable[] = {0}; <span class="comment">//The list of clusters that the endpoint will support</span>

<span class="comment">//Configure the simple descriptor of the endpoint</span>
<span class="keyword">static</span> <a class="code" href="struct_simple_descriptor__t.html" title="Simple Descriptor.">SimpleDescriptor_t</a> simpleDescriptor =
{
  .<a class="code" href="struct_simple_descriptor__t.html#a983c8e6db56e62edd64e8985c36b7cac">endpoint</a> = APP_ENDPOINT, <span class="comment">//Endpoint ID, an arbitrary number between 1 and 240</span>
  .AppDeviceVersion = 1,
  .AppInClustersCount = 1, <span class="comment">//The number of suppoted input clusters</span>
  .AppInClustersList = clustersTable,  <span class="comment">//The list of supported input clusters</span>
  .AppOutClustersCount = 0,
  .AppOutClustersList = NULL, <span class="comment">//Suppose out clusters are not supported</span>
};

<span class="comment">//Configure parameters for endpoint registration request</span>
<span class="keyword">static</span> <a class="code" href="struct_a_p_s___register_endpoint_req__t.html" title="Parameters of the APS_RegisterEndpointReq() function.">APS_RegisterEndpointReq_t</a> endpointDesc =
{
  .<a class="code" href="struct_a_p_s___register_endpoint_req__t.html#a0f59b6a67d5ba5957aedc565f5db1fac">simpleDescriptor</a> = &amp;simpleDescriptor,
  .APS_DataInd = APS_DataInd,
};

<span class="comment">//Data indication callback definition</span>
<span class="keyword">static</span> <span class="keywordtype">void</span> APS_DataInd(<a class="code" href="struct_a_p_s___data_ind__t.html" title="The structure for indication of data reception.">APS_DataInd_t</a> *ind)
{
  <span class="comment">//Perform appropriate actions, for example, switch on the value of</span>
  <span class="comment">//cluster specified in the received frame</span>
  <span class="keywordflow">switch</span> (ind-&gt;<a class="code" href="struct_a_p_s___data_ind__t.html#a9fa5bf20bb19a53c2cf90d2421490cb1">clusterId</a>)
  {
    <span class="keywordflow">case</span> CPU_TO_LE16(APP_CLUSTER_ONE):
    ...
    case CPU_TO_LE16(APP_CLUSTER_TWO):
    ...
  }
}
...
simpleDescriptor.AppProfileId = CPU_TO_LE16(APP_PROFILE_ID);
simpleDescriptor.<a class="code" href="struct_simple_descriptor__t.html#a82725380f3c264735ab5bbc6abd0a8d3">AppDeviceId</a> = CPU_TO_LE16(1);

<a class="code" href="group__aps__data.html#gad5e605753e1707e9caecb218e6cb4a7b" title="Registers a new endpoint in the APS layer.">APS_RegisterEndpointReq</a>(&amp;endpointDesc);
</pre></div><p> Although it is not required that a variable for the simple descriptor is static or simply defined in the global scope, it may be convenient to do so to keep track of the endpoint. Note the use of the CPU_TO_LE16 macro which converts a 16-bit value to a 16-bit little-endian value. Backward convertion is performed with the LE16_TO_CPU macro.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">req</td><td>- pointer to the endpoint registration request parameters</td></tr>
  </table>
  </dd>
</dl>
<dl class="user"><dt><b>Response statuses (req-&gt;status values):</b></dt><dd><a class="el" href="aps_common_8h.html#a1b4ff3a412400f1920d4d56e771230c8a0787d3e34ec427cb7d3107395f348538">APS_SUCCESS_STATUS</a> (0x00) - if registration is a success <br/>
 <a class="el" href="aps_common_8h.html#a1b4ff3a412400f1920d4d56e771230c8a9b42810982eb191bbbfa37a43cd369bc">APS_INVALID_PARAMETER_STATUS</a> (0xA6) - if invalid parameters are provided, or such endpoint is already registered </dd></dl>

</div>
</div>
<a class="anchor" id="ga36d0e55efedd5c7e391ddce10695afa8"></a><!-- doxytag: member="apsdeEndpoint.h::APS_UnregisterEndpointReq" ref="ga36d0e55efedd5c7e391ddce10695afa8" args="(APS_UnregisterEndpointReq_t *const req)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void APS_UnregisterEndpointReq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_a_p_s___unregister_endpoint_req__t.html">APS_UnregisterEndpointReq_t</a> *const&#160;</td>
          <td class="paramname"><em>req</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unregisters an endpoint from the APS layer. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">req</td><td>- pointer to the endpoint unregistering request parameters</td></tr>
  </table>
  </dd>
</dl>
<dl class="user"><dt><b>Response statuses (req-&gt;status values):</b></dt><dd><a class="el" href="aps_common_8h.html#a1b4ff3a412400f1920d4d56e771230c8a0787d3e34ec427cb7d3107395f348538">APS_SUCCESS_STATUS</a> - if the endpoint has been unregistered successfully <br/>
 <a class="el" href="aps_common_8h.html#a1b4ff3a412400f1920d4d56e771230c8a9b42810982eb191bbbfa37a43cd369bc">APS_INVALID_PARAMETER_STATUS</a> (0xA6) - if invalid parameters are provided, or the endpoint is not registered </dd></dl>

</div>
</div>
<a class="anchor" id="ga37c9fc2e3eceef1f27559ab5efa69c87"></a><!-- doxytag: member="apsdeEndpoint.h::APS_NextEndpoint" ref="ga37c9fc2e3eceef1f27559ab5efa69c87" args="(const APS_RegisterEndpointReq_t *const prev)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_a_p_s___register_endpoint_req__t.html">APS_RegisterEndpointReq_t</a>* APS_NextEndpoint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_a_p_s___register_endpoint_req__t.html">APS_RegisterEndpointReq_t</a> *const&#160;</td>
          <td class="paramname"><em>prev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get next registered endpoint descriptor by previous. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">prev</td><td>- previous endpoint descriptor pointer.It is must be non NULL sequential access required if. And it is must be NULL the first descriptor as registered endpoints queue head element access required if.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>Valid endpoint descriptor pointer descriptor found if, NULL - other case. </dd></dl>

</div>
</div>
<a class="anchor" id="ga72972ae4e955a5f249aa64e23a5b0f79"></a><!-- doxytag: member="apsdeEndpoint.h::APS_StopEndpointIndication" ref="ga72972ae4e955a5f249aa64e23a5b0f79" args="(const Endpoint_t endpoint)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void APS_StopEndpointIndication </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="app_framework_8h.html#a2b4bc3df040a6181a3665c8e5ab24142">Endpoint_t</a>&#160;</td>
          <td class="paramname"><em>endpoint</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Stops APS Data indications of specific endpoint number. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">endpoint</td><td>- the registered endpoint number. The 0xff special value means all registered endpoints. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="gaccb3b92dde84e5918cd777ed6837daec"></a><!-- doxytag: member="apsdeEndpoint.h::APS_ResumeEndpointIndication" ref="gaccb3b92dde84e5918cd777ed6837daec" args="(const Endpoint_t endpoint)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void APS_ResumeEndpointIndication </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="app_framework_8h.html#a2b4bc3df040a6181a3665c8e5ab24142">Endpoint_t</a>&#160;</td>
          <td class="paramname"><em>endpoint</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Resumes APS Data indications of specific endpoint number. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">endpoint</td><td>- the registered endpoint number. The 0xff special value means all registered endpoints. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="ga00f4be3114dfcee6e2a6409b19adf6fb"></a><!-- doxytag: member="apsmeBind.h::APS_BindReq" ref="ga00f4be3114dfcee6e2a6409b19adf6fb" args="(APS_BindReq_t *const req)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void APS_BindReq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_a_p_s___bind_req__t.html">APS_BindReq_t</a> *const&#160;</td>
          <td class="paramname"><em>req</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Bind to a remote device or a group. </p>
<p>This function establishes binding of two devices, or binding of a device to a group, by creating an entry in the lcoal binding table, if supported. The function follows the primitive defined in ZigBee specification r18, 2.2.4.3.1, page 34.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">req</td><td>- pointer to request's parameters: source and destination addresses, cluster identifier and etc. </td></tr>
  </table>
  </dd>
</dl>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="struct_a_p_s___data_req__t.html" title="The structure for request parameters of APS_DataReq() function.">APS_DataReq_t</a>. </dd></dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<p><a class="anchor" id="BindReqStatuses"></a> </p>
<dl class="user"><dt><b>Response statuses:</b></dt><dd>Accessed via the <a class="el" href="struct_a_p_s___bind_conf__t.html#ae4ea646840de13c180116397c28251dc">APS_BindConf_t::status</a> field of the <a class="el" href="struct_a_p_s___bind_req__t.html#abef8174603bb53c59fdb7e17d3786f3e">APS_BindReq_t::confirm</a> argument's field <br/>
<br/>
 <a class="el" href="aps_common_8h.html#a1b4ff3a412400f1920d4d56e771230c8a0787d3e34ec427cb7d3107395f348538">APS_SUCCESS_STATUS</a> (0x00) - the binding link has been successfully created <br/>
 <a class="el" href="aps_common_8h.html#a1b4ff3a412400f1920d4d56e771230c8aaab46766e6832edee99f3bb818e0e49a">APS_TABLE_FULL_STATUS</a> (0xAE) - the binding table capacity had been exceeded <br/>
 <a class="el" href="aps_common_8h.html#a1b4ff3a412400f1920d4d56e771230c8ace981009ed1c4b195b37942542485146">APS_NOT_SUPPORTED_STATUS</a> (0xAA) - the device does not support the binding table <br/>
 <a class="el" href="aps_common_8h.html#a1b4ff3a412400f1920d4d56e771230c8a862dced50276200ed041b479e9e960b9">APS_ILLEGAL_REQUEST_STATUS</a> (0xA3) - the device is not joined to a network, or one of the parameters has a value that is out of range </dd></dl>

</div>
</div>
<a class="anchor" id="gab418bf268ff652a18f4a2c0c89a18504"></a><!-- doxytag: member="apsmeBind.h::APS_UnbindReq" ref="gab418bf268ff652a18f4a2c0c89a18504" args="(APS_UnbindReq_t *const req)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void APS_UnbindReq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_a_p_s___unbind_req__t.html">APS_UnbindReq_t</a> *const&#160;</td>
          <td class="paramname"><em>req</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Unbind device from a group or from other device. </p>
<p>This function performs unbinding of two devices, or unbinding of a device from a group, by removing an entry in the local binding table, if supported. The function follows the primitive defined in ZigBee specification r18, 2.2.4.3.3, page 38.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">req</td><td>- pointer to request's parameters.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None.</dd></dl>
<dl class="user"><dt><b>Response statuses:</b></dt><dd>Accessed via the APS_UnbindConf_t::status field of the APS_UnbindReq_t::confirm argument's field <br/>
<br/>
 <a class="el" href="aps_common_8h.html#a1b4ff3a412400f1920d4d56e771230c8a0787d3e34ec427cb7d3107395f348538">APS_SUCCESS_STATUS</a> (0x00) - the binding link has been successfully removed <br/>
 <a class="el" href="aps_common_8h.html#a1b4ff3a412400f1920d4d56e771230c8a27b45afba80e0eaf879f646925179682">APS_INVALID_BINDING_STATUS</a> (0xA4) - the binding entry has not been found </dd></dl>

</div>
</div>
<a class="anchor" id="ga2215898e304af0bcd4e9df5f34c15363"></a><!-- doxytag: member="apsmeBind.h::APS_DeactivateBindRecords" ref="ga2215898e304af0bcd4e9df5f34c15363" args="(const ExtAddr_t *const dstAddr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void APS_DeactivateBindRecords </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="mac_addr_8h.html#a5b2913b1523fd1ce0a399c4fb047cc8b">ExtAddr_t</a> *const&#160;</td>
          <td class="paramname"><em>dstAddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Deactivates all records in the binding table that contain dstAddr as the destination address in a binding entry. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dstAddr</td><td>- pointer to the target extended address</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="ga3e47e895602ee6cd05c8bbeebbc8d833"></a><!-- doxytag: member="apsmeBind.h::APS_ActivateBindRecords" ref="ga3e47e895602ee6cd05c8bbeebbc8d833" args="(const ExtAddr_t *const dstAddr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void APS_ActivateBindRecords </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="mac_addr_8h.html#a5b2913b1523fd1ce0a399c4fb047cc8b">ExtAddr_t</a> *const&#160;</td>
          <td class="paramname"><em>dstAddr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Activates all records in the binding table that contain dstAddr as the destination address in a binding entry. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dstAddr</td><td>- pointer to the target extended address</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>None </dd></dl>

</div>
</div>
<a class="anchor" id="ga0a8ea1dab11d0956e9145e60a672935f"></a><!-- doxytag: member="apsmeBind.h::APS_NextBindingEntry" ref="ga0a8ea1dab11d0956e9145e60a672935f" args="(ApsBindingEntry_t *entry)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_aps_binding_entry__t.html">ApsBindingEntry_t</a>* APS_NextBindingEntry </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_aps_binding_entry__t.html">ApsBindingEntry_t</a> *&#160;</td>
          <td class="paramname"><em>entry</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Get a next binding entry. </p>
<div class="fragment"><pre class="fragment"> Example:
    <a class="code" href="struct_aps_binding_entry__t.html" title="A type for a binding table entry.">ApsBindingEntry_t</a> *bindingEntry = NULL;

    <span class="keywordflow">while</span> (NULL != (bindingEntry = <a class="code" href="group__aps__data.html#ga0a8ea1dab11d0956e9145e60a672935f" title="Get a next binding entry.">APS_NextBindingEntry</a>(bindingEntry)))
    {
      <span class="keywordflow">if</span> (0x1234 == bindingEntry-&gt;clusterId)
        ...
      ...
    }
</pre></div><dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">entry</td><td>- pointer to binding entry or NULL if it's initial call.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>if next binding entry is found then return valid pointer otherwise return NULL. </dd></dl>

</div>
</div>
<a class="anchor" id="ga64bb9bf327968a882d9c81f0cbc67f5a"></a><!-- doxytag: member="apsmeGroup.h::APS_AddGroupReq" ref="ga64bb9bf327968a882d9c81f0cbc67f5a" args="(APS_AddGroupReq_t *const req)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void APS_AddGroupReq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_a_p_s___add_group_req__t.html">APS_AddGroupReq_t</a> *const&#160;</td>
          <td class="paramname"><em>req</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Adds the current device to the members of a certain group. </p>
<p>The function makes the current device a member of the specified group. A call to the function is done synchronously since no requests are sent to the network. Instead, the function simply adds a new entry to the group table associating the group address and the endpoint ID specified within the parameters. The function can be called several times with the same group address and different endpoints which will cause inserting an entry for each distinct pair of the group address and an endpoint. When a data frame is sent to a group each group member upon reception of the frame fires indication callbacks for all endpoints associated with the group address specified in the request.</p>
<p>The result of task execution is indicated by <a class="el" href="struct_a_p_s___add_group_req__t.html#a1526a3ca4dc96e1dc1b5a6747a696cef">APS_AddGroupReq_t::confirm</a> property inside the request parameters. The status field reports </p>
<ul>
<li><a class="el" href="aps_common_8h.html#a1b4ff3a412400f1920d4d56e771230c8a0787d3e34ec427cb7d3107395f348538">APS_SUCCESS_STATUS</a> (0x00) if the device has been added to the group </li>
<li><a class="el" href="aps_common_8h.html#a1b4ff3a412400f1920d4d56e771230c8aaab46766e6832edee99f3bb818e0e49a">APS_TABLE_FULL_STATUS</a> (0xAE) if the group table is full and a new entry can not be added.</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">req</td><td>- pointer to parameters of the APSME-ADD-GROUP.request. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga1817dc1d30b3634608cbab0b14c4819c"></a><!-- doxytag: member="apsmeGroup.h::APS_RemoveGroupReq" ref="ga1817dc1d30b3634608cbab0b14c4819c" args="(APS_RemoveGroupReq_t *const req)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void APS_RemoveGroupReq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_a_p_s___remove_group_req__t.html">APS_RemoveGroupReq_t</a> *const&#160;</td>
          <td class="paramname"><em>req</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Removes the current device from the members of a certain group. </p>
<p>The function removes the node from a group. A call to the function is done synchronously. The function drops all entries with the specified group and endpoint inside from the group table.</p>
<p>The result of task execution is indicated by <a class="el" href="struct_a_p_s___add_group_req__t.html#a1526a3ca4dc96e1dc1b5a6747a696cef">APS_AddGroupReq_t::confirm</a> property inside the request parameters. The status field reports </p>
<ul>
<li><a class="el" href="aps_common_8h.html#a1b4ff3a412400f1920d4d56e771230c8a0787d3e34ec427cb7d3107395f348538">APS_SUCCESS_STATUS</a> (0x00) if the device has been removed from the group </li>
<li><a class="el" href="aps_common_8h.html#a1b4ff3a412400f1920d4d56e771230c8a9b42810982eb191bbbfa37a43cd369bc">APS_INVALID_PARAMETER_STATUS</a> (0xA6) if requested entry has not been found in the group table</li>
</ul>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">req</td><td>- pointer to parameters of the APSME-REMOVE-GROUP.request. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gabffb03739264507fe711c79c38a2cb43"></a><!-- doxytag: member="apsmeGroup.h::APS_RemoveAllGroupsReq" ref="gabffb03739264507fe711c79c38a2cb43" args="(APS_RemoveAllGroupsReq_t *const req)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void APS_RemoveAllGroupsReq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_a_p_s___remove_all_groups_req__t.html">APS_RemoveAllGroupsReq_t</a> *const&#160;</td>
          <td class="paramname"><em>req</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Removes the current device from the members of all groups for which a given endpoint if registered. </p>
<p>The function unscribe the current device from the members of all groups for which a given endpoint is registered. To fullfill the task the function deletes all entries with a given endpoint inside from the group table. If 0xFF is specified for endpoint the node is removed from all groups.</p>
<p>The result of task execution is indicated by <a class="el" href="struct_a_p_s___add_group_req__t.html#a1526a3ca4dc96e1dc1b5a6747a696cef">APS_AddGroupReq_t::confirm</a> field inside the request parameters.</p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">req</td><td>- pointer to parameters of the APSME-REMOVE-ALL-GROUPS.request. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div>
<hr style="border-top:1px solid #C4CFE5; margin-top:20px"/>
</body>
</html>
