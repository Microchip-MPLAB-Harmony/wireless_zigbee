<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>PIC32CX-BZ Zigbee API Reference: Using the APS component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">PIC32CX-BZ Zigbee API Reference</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">Using the APS component </div>  </div>
</div>
<div class="contents">
<div class="textblock"><p>The application support sub-layer (APS) provides an interface between the network layer (NWK) and the application layer (APL) through a general set of services. The sections below describe the most common tasks performed with the use of APS.</p>
<p><span class="table_of_contents">References</span> </p>
<ul>
<li>
<a class="el" href="group__aps.html">APS functions</a> <ul>
<li>
<a class="el" href="group__aps__data.html">Data related functions</a> </li>
<li>
<a class="el" href="group__aps__security.html">Security</a> </li>
</ul>
</li>
<li>
<a class="el" href="aps_common_8h.html#a1b4ff3a412400f1920d4d56e771230c8">APS status codes </a> </li>
</ul>
 
<hr style="border-top:1px solid #E0E0FF; margin-top:10px"/>

<span class="table_of_contents">Contents</span>
<ul class="table_of_contents">
  <li><a href="#endpoints">Endpoint registration</a></li>
  <li>
    <a href="#data_exchange">Data exchange</a>
    <ul>
      <li><a href="#payload_config">Configuring a payload</a></li>
      <li><a href="#short_addressing">Using short addresses for the destination</a></li>
      <li><a href="#ext_addressing">Using extended addresses for the destination</a></li>
      <li><a href="#group_addressing">Using group addresses for the destination</a></li>
      <li><a href="#broadcast">Broadcasting</a></li>
      <li><a href="#ack">Acknowledged data transmission</a></li>
      <li><a href="#data_req_binding">Applying binding for data transmission</a></li>
      <li><a href="#sec_data_req">Data transmission in secured networks</a></li>
      <li><a href="#to_all_endpoints">Sending a message to all endpoints on destination nodes</a></li>
      <li><a href="#radius">Limiting the radius of a data frame</a></li>
    </ul>
  </li>
  <li><a href="#group_management">Managing groups</a></li>
  <li>
    <a href="#binding">Binding</a>
    <ul>
      <li><a href="#bind_single">Binding to a single node</a></li>
      <li><a href="#bind_group">Binding to a group</a></li>
      <li><a href="#unbind">Unbinding</a></li>
      <li><a href="#iter_binding_table">Iterating through the binding table</a></li>
    </ul>
  </li>
  <li>
    <a href="#high_sec_api">Using security keys API</a>
    <ul>
      <li><a href="#key_mgmt_overview">Key management API overview</a></li>
      <li><a href="#set_link_key">Setting link keys</a></li>
      <li><a href="#request_link_key">Request for a link key</a></li>
      <!--<li><a href="#master_key">Setting a master key</a></li>-->
    </ul>
  </li>
</ul>
<p></p>
 <span class="to_top"><a href="#">Back to top</a></span>  <h2><a class="anchor" id="endpoints"></a>
Endpoint registration</h2>
<p>An endpoint is an object corresponding to a certain application object. In ZigBee networks an endpoint is used as a source or a destination for a data exchange. Moreover, on the application level the only way to send data is from one endpoint to another. To use an endpoint the application must first register it. Endpoint registration is performed via the <a class="el" href="group__aps__data.html#gad5e605753e1707e9caecb218e6cb4a7b" title="Registers a new endpoint in the APS layer.">APS_RegisterEndpointReq()</a> function.</p>
<p>To register an endpoint on the current device, first, define a simple descriptor that specifies properties of the endpoint you would like to register. The simple descriptor should be an instance of type <a class="el" href="struct_simple_descriptor__t.html" title="Simple Descriptor.">SimpleDescriptor_t</a> provided as a variable defined in a global scope. An endpoint on a given device is identified by an endpoint ID that is a value in a range from 1 to 240. Other parameters include the application profile ID, device type ID (within the specified profile ID), and lists of input and output clusters. Simple applications that are not intended to use public application profiles can define an arbitrary value for the application profile ID, for example, 1. If clusters are not going to be specified then <code>NULL</code> should be passed.</p>
<p>To register an endpoint call the <a class="el" href="group__aps__data.html#gad5e605753e1707e9caecb218e6cb4a7b" title="Registers a new endpoint in the APS layer.">APS_RegisterEndpointReq()</a> function passing a pointer to request parameters instance of the <a class="el" href="struct_a_p_s___register_endpoint_req__t.html" title="Parameters of the APS_RegisterEndpointReq() function.">APS_RegisterEndpointReq_t</a> type. Besides the simple descriptor the request parameters require a pointer to a callback which is to be called when data destined for the endpoint is received.</p>
<p>The following example illustrates the endpoint registration process:</p>
<div class="fragment"><pre class="fragment"><span class="comment">//Define a simple descriptor for the endpoint</span>
<a class="code" href="struct_simple_descriptor__t.html" title="Simple Descriptor.">SimpleDescriptor_t</a> simpleDescriptor = { APP_ENDPOINT, APP_PROFILE_ID, 1, 1, 0, 0, NULL, 0, NULL };
<span class="comment">//A variable for registering endpoint parameters</span>
<a class="code" href="struct_a_p_s___register_endpoint_req__t.html" title="Parameters of the APS_RegisterEndpointReq() function.">APS_RegisterEndpointReq_t</a> endpointParams;

<span class="comment">//The data indication callback to handle data reception on the endpoint</span>
<span class="keywordtype">void</span> APS_DataIndication(<a class="code" href="struct_a_p_s___data_ind__t.html" title="The structure for indication of data reception.">APS_DataInd_t</a> *ind)
{
  ...
}
...
<span class="comment">//Set endpoint registration request parameters</span>
endpointParams.<a class="code" href="struct_a_p_s___register_endpoint_req__t.html#a0f59b6a67d5ba5957aedc565f5db1fac">simpleDescriptor</a> = &amp;simpleDescriptor;
endpointParams.<a class="code" href="struct_a_p_s___register_endpoint_req__t.html#ac03f6c56093b097a0a22b4ff7aa7dfa9">APS_DataInd</a> = APS_DataIndication;

<span class="comment">//Register endpoint</span>
<a class="code" href="group__aps__data.html#gad5e605753e1707e9caecb218e6cb4a7b" title="Registers a new endpoint in the APS layer.">APS_RegisterEndpointReq</a>(&amp;endpointParams);
</pre></div><p>The above code configures and registers the endpoint with the ID equal to <code>APP_ENDPOINT</code>, the profile ID equal to <code>APP_PROFILE_ID</code>, and with no input and output clusters specified. The function call is done synchronously. The result of the operation is reported by the <code>status</code> field of the request parameters.</p>
 <span class="to_top"><a href="#">Back to top</a></span>  <h2><a class="anchor" id="data_exchange"></a>
Data exchange</h2>
<p>To transmit data from the device to other network devices use the <a class="el" href="group__aps__data.html#ga2a584bc786c377e3e69b0896b0d0a55f" title="Sends data to a node in the network.">APS_DataReq()</a> function. The function needs a pointer to an instance of the <a class="el" href="struct_a_p_s___data_req__t.html" title="The structure for request parameters of APS_DataReq() function.">APS_DataReq_t</a> type as an argument. Required request parameters include a pointer to a confirmation callback function, information about the source and the destination, and the payload. There are several methods to identify the destination; for all of them the payload configuration is done in the same way. Addressing mode is given by the <code>dstAddrMode</code> field of the request parameters.</p>
<h3><a class="anchor" id="payload_config"></a>
Configuring a payload</h3>
<p>The application shall allocate a continuous block of memory as a message buffer. The buffer must include the space for the APS header, the payload, which is to hold the actual message data, and the APS footer. The size of the APS header is given by the <a class="el" href="aps_common_8h.html#aced3428fa1b564c0995349a95d756133">APS_ASDU_OFFSET</a> constant. The size of the footer can be calculated as <a class="el" href="aps_common_8h.html#a1cf798a2f6651855a2e70cdd1f727540">APS_AFFIX_LENGTH</a> - <a class="el" href="aps_common_8h.html#aced3428fa1b564c0995349a95d756133">APS_ASDU_OFFSET</a>. The payload size is arbitrary. The maximum payload size that fits one data frame depends on the security level used. If the actual payload size is greater than the maximum payload size, the application should split the data into smaller pieces or use the fragmentation feature. The message buffer can be represented by the following structure:</p>
<div class="fragment"><pre class="fragment"><span class="comment">//Application message buffer structure</span>
BEGIN_PACK
<span class="keyword">typedef</span> <span class="keyword">struct</span>
{
  uint8_t header[<a class="code" href="aps_common_8h.html#aced3428fa1b564c0995349a95d756133">APS_ASDU_OFFSET</a>]; <span class="comment">//APS header</span>
  uint8_t data[APP_ASDU_SIZE]; <span class="comment">//Application data - the payload</span>
  uint8_t footer[<a class="code" href="aps_common_8h.html#a1cf798a2f6651855a2e70cdd1f727540">APS_AFFIX_LENGTH</a> - <a class="code" href="aps_common_8h.html#aced3428fa1b564c0995349a95d756133">APS_ASDU_OFFSET</a>]; <span class="comment">// Footer</span>
} PACK AppMessageBuffer_t;
END_PACK
</pre></div><p><code>BEGIN_PACK</code>, <code>PACK</code>, and <code>END_PACK</code> macros are used to swith off data alignment for the structure thus making it representation in memory continuous. <code>APP_ASDU_SIZE</code> is assumed to be an application defined constant.</p>
<p>After the message buffer is defined the application can use it to specify data to be transmitted as follows</p>
<div class="fragment"><pre class="fragment">AppMessageBuffer_t appMessageBuffer; <span class="comment">//A variable for the message buffer</span>
<a class="code" href="struct_a_p_s___data_req__t.html" title="The structure for request parameters of APS_DataReq() function.">APS_DataReq_t</a> dataReq; <span class="comment">//A variable for the request parameters</span>
...
<span class="comment">//Specify the request parameters</span>
dataReq.<a class="code" href="struct_a_p_s___data_req__t.html#a196dc99b4a0bfea6ca3ad9871ff05c64">asdu</a> = appMessageBuffer.data;
dataReq.<a class="code" href="struct_a_p_s___data_req__t.html#ac3c1cc5c8134f4fe663aeefc58d98f68">asduLength</a> = <span class="keyword">sizeof</span>(appMessageBuffer.data);
</pre></div><p>The <code>asdu</code> field of request parameters shall point to the data section of the message buffer and the <code>asduLength</code> field shall equal its length.</p>
<h3><a class="anchor" id="short_addressing"></a>
Using short addresses for the destination</h3>
<p>To use short addresses assign the <code>dstAddrMode</code> field in the request parameters to <a class="el" href="aps_common_8h.html#a0bc5b23d1c85adcef057f8c04dfc5365ae7b258974e64c3310ce05109e944f308">APS_SHORT_ADDRESS</a>. This type of addressing can be used to send a unicast message to a particular node with a given short address or to <a href="#broadcast">send a broadcast message</a>. For a unicast message specify the destination short address via the <code>dstAddress.shortAddress</code> field.</p>
<p>Besides the addressing mode, the destination address, and the callback, the required fields include the destination and the source endpoints, the profile ID, and the cluster ID. The profile ID must be the same on the source and the destionation endpoints. The specified cluster must be supported on the source endpoint as an output cluster and as an input cluster on the destination endpoint. The example below shows how to send a unicast message:</p>
<div class="fragment"><pre class="fragment">AppMessageBuffer_t appMessageBuffer; <span class="comment">//A variable for the message buffer</span>
<a class="code" href="struct_a_p_s___data_req__t.html" title="The structure for request parameters of APS_DataReq() function.">APS_DataReq_t</a> dataReq; <span class="comment">//A variable for the request parameters</span>
<span class="comment">//A confirmation callback for APS_DataReq()</span>
<span class="keyword">static</span> <span class="keywordtype">void</span> APS_DataConf(<a class="code" href="struct_a_p_s___data_conf__t.html" title="The structure for reporting the result of APS_DataReq() function.">APS_DataConf_t</a> *confInfo)
{
  ...
}
...
dataReq.<a class="code" href="struct_a_p_s___data_req__t.html#a78008f477ee82a519794580047eafa31">profileId</a> = APP_PROFILE_ID;
dataReq.<a class="code" href="struct_a_p_s___data_req__t.html#acf9d887c5027cc63f2328661bfe5f532">dstAddrMode</a> = <a class="code" href="aps_common_8h.html#a0bc5b23d1c85adcef057f8c04dfc5365ae7b258974e64c3310ce05109e944f308">APS_SHORT_ADDRESS</a>;
dataReq.<a class="code" href="struct_a_p_s___data_req__t.html#ad777a242d9d90e4c9eed819a8ba0c7c1">dstAddress</a>.<a class="code" href="union_a_p_s___address__t.html#a0acbc0fe2e3c5a8b9e5529fe714a76a9">shortAddress</a> = CPU_TO_LE16(0x0001);
dataReq.<a class="code" href="struct_a_p_s___data_req__t.html#a735d3b4ba36dc998fa64f77bb21c3949">dstEndpoint</a> = DST_ENDPOINT_ID;
dataReq.<a class="code" href="struct_a_p_s___data_req__t.html#a48256007954e7a4e9b85ef0c166e9a93">clusterId</a> = CPU_TO_LE16(SAMPLE_CLUSTER_ID);
dataReq.<a class="code" href="struct_a_p_s___data_req__t.html#ac816e4593f69008682cf3fa697aef65b">srcEndpoint</a> = SRC_ENDPOINT_ID;
dataReq.<a class="code" href="struct_a_p_s___data_req__t.html#afb9d6e8ddb106b90557107a92d1408ca">radius</a> = 0x0;
<span class="comment">//Specify a callback</span>
dataReq.<a class="code" href="struct_a_p_s___data_req__t.html#a008411aa3c3ab38f4646c976b7163f3b">APS_DataConf</a> = APS_DataConf;
<span class="comment">//Configure the payload</span>
dataReq.<a class="code" href="struct_a_p_s___data_req__t.html#a196dc99b4a0bfea6ca3ad9871ff05c64">asdu</a> = appMessageBuffer.data;
dataReq.<a class="code" href="struct_a_p_s___data_req__t.html#ac3c1cc5c8134f4fe663aeefc58d98f68">asduLength</a> = <span class="keyword">sizeof</span>(appMessageBuffer.data);

<span class="comment">//Issue the request</span>
<a class="code" href="group__aps__data.html#ga2a584bc786c377e3e69b0896b0d0a55f" title="Sends data to a node in the network.">APS_DataReq</a>(&amp;dataReq);
</pre></div><p>A data is sent to the node with short address equal to 0x0001. To send a broadcast message change the <code>dstAddress.shortAddress</code> value to a broadcast address, for example:</p>
<div class="fragment"><pre class="fragment">...
dataReq.dstAddress.shortAddress = <a class="code" href="nwk_common_8h.html#aea30e2107b74c7ed585468c42b8d2cff">BROADCAST_ADDR_ALL</a>;
...
</pre></div><p>It is assumed in the example that there are such application-defined constants as <code>DST_ENDPOINT_ID</code>, <code>SRC_ENDPOINT_ID</code>, <code>APP_PROFILE_ID</code>, and <code>SAMPLE_CLUSTER_ID</code>. Note the use of <code>CPU_TO_LE16</code> macro, which transforms a 16-bit value to a little endian value. If the value is symmetric, like 0x000 or 0xFFFF, then the macro can be safely omitted.</p>
<h3><a class="anchor" id="ext_addressing"></a>
Using extended addresses for the destination</h3>
<p>A destination device for data transmission can be identified with the extended address. For this purpose, set the <code>dstAddrMode</code> field of request parameters for <a class="el" href="group__aps__data.html#ga2a584bc786c377e3e69b0896b0d0a55f" title="Sends data to a node in the network.">APS_DataReq()</a> to <a class="el" href="aps_common_8h.html#a0bc5b23d1c85adcef057f8c04dfc5365a5c4534edda395953500e62e45f1b51de">APS_EXT_ADDRESS</a> and <code>dstAddress.extAddress</code> to the actual value of the extended address.</p>
<p>In order to transfer a data frame to the destination determined by the extended address Microchip Zigbee still needs the short address as well. During APS data request execution the stack searches for the short address associated with a given extended address in the address map table. An entry containing short and extended addresses should be inserted into the address map previously. If the entry is not found the stack calls the callback with the <a class="el" href="aps_common_8h.html#a1b4ff3a412400f1920d4d56e771230c8a47d2ecca7d87082b977399f53e439421">APS_NO_SHORT_ADDRESS_STATUS</a> value.</p>
<p>An entry is added to the address map table upon completion of a proper Device Discovery request, that is, a ZDP request of <a class="el" href="zdo_common_8h.html#aaf8fd5f0e57d456151c951e0f3715fc4a5f82e8ee6326f3c9011130028c2150b6" title="Request for the 64-bit IEEE address of a remote device based on its known 16-bit address.">IEEE_ADDR_CLID</a> type. See <a href="zdo_usage.html#zdp_device_discovery">the example</a>.</p>
<h3><a class="anchor" id="group_addressing"></a>
Using group addresses for the destination</h3>
<p>To send a message to all members of a certain group set the <code>dstAddrMode</code> field of request parameters to <a class="el" href="aps_common_8h.html#a0bc5b23d1c85adcef057f8c04dfc5365ae7d06d84db475a76cfb47e96347c8505">APS_GROUP_ADDRESS</a> and assign <code>dstAddress.groupAddress</code> to a group address. If the destination endpoint is set to <code>0xFF</code> indication will be raised only for endpoints that are registered with the given group address. Otherwise, an indication will be raised on the specified endpoint, but only if it is registered with the received group address.</p>
<div class="fragment"><pre class="fragment">AppMessageBuffer_t appMessageBuffer; <span class="comment">//A variable for the message buffer</span>
<a class="code" href="struct_a_p_s___data_req__t.html" title="The structure for request parameters of APS_DataReq() function.">APS_DataReq_t</a> dataReq; <span class="comment">//A variable for the request parameters</span>
<span class="comment">//A confirmation callback for APS_DataReq()</span>
<span class="keywordtype">void</span> APS_DataConf(<a class="code" href="struct_a_p_s___data_conf__t.html" title="The structure for reporting the result of APS_DataReq() function.">APS_DataConf_t</a> *confInfo)
{
  ...
}
...
dataReq.<a class="code" href="struct_a_p_s___data_req__t.html#a78008f477ee82a519794580047eafa31">profileId</a> = APP_PROFILE_ID;
dataReq.<a class="code" href="struct_a_p_s___data_req__t.html#ac816e4593f69008682cf3fa697aef65b">srcEndpoint</a> = SRC_ENDPOINT_ID;
dataReq.<a class="code" href="struct_a_p_s___data_req__t.html#acf9d887c5027cc63f2328661bfe5f532">dstAddrMode</a> = <a class="code" href="aps_common_8h.html#a0bc5b23d1c85adcef057f8c04dfc5365ae7d06d84db475a76cfb47e96347c8505">APS_GROUP_ADDRESS</a>;
dataReq.<a class="code" href="struct_a_p_s___data_req__t.html#ad777a242d9d90e4c9eed819a8ba0c7c1">dstAddress</a>.<a class="code" href="union_a_p_s___address__t.html#abf0c56b1155298647a9f52486eb6da7f">groupAddress</a> = CPU_TO_LE16(0x0001);
dataReq.<a class="code" href="struct_a_p_s___data_req__t.html#a735d3b4ba36dc998fa64f77bb21c3949">dstEndpoint</a> = DST_ENDPOINT_ID;
dataReq.<a class="code" href="struct_a_p_s___data_req__t.html#a48256007954e7a4e9b85ef0c166e9a93">clusterId</a> = CPU_TO_LE16(SAMPLE_CLUSTER_ID);

dataReq.<a class="code" href="struct_a_p_s___data_req__t.html#afb9d6e8ddb106b90557107a92d1408ca">radius</a> = 0x0;
<span class="comment">//Specify a callback</span>
dataReq.<a class="code" href="struct_a_p_s___data_req__t.html#a008411aa3c3ab38f4646c976b7163f3b">APS_DataConf</a> = APS_DataConf;
<span class="comment">//Configure the payload</span>
dataReq.<a class="code" href="struct_a_p_s___data_req__t.html#a196dc99b4a0bfea6ca3ad9871ff05c64">asdu</a> = appMessageBuffer.data;
dataReq.<a class="code" href="struct_a_p_s___data_req__t.html#ac3c1cc5c8134f4fe663aeefc58d98f68">asduLength</a> = <span class="keyword">sizeof</span>(appMessageBuffer.data);

<span class="comment">//Issue the request</span>
<a class="code" href="group__aps__data.html#ga2a584bc786c377e3e69b0896b0d0a55f" title="Sends data to a node in the network.">APS_DataReq</a>(&amp;dataReq);
</pre></div><p>It is assumed in the example that there are such application-defined constants as <code>DST_ENDPOINT_ID</code>, <code>SRC_ENDPOINT_ID</code>, <code>APP_PROFILE_ID</code>, and <code>SAMPLE_CLUSTER_ID</code>. The data is sent to all members of the group with the group address equal to 1. Note the use of <code>CPU_TO_LE16</code> macro, which transforms a 16-bit value to a little endian value. If the value is symmetric, like 0x000 or 0xFFFF, then the macro can be safely omitted.</p>
<p>To find out how to add a device to a group see <a href="#group_management">Managing groups</a>.</p>
<h3><a class="anchor" id="broadcast"></a>
Broadcasting</h3>
<p>To send a message to all nodes in the network or to all routers the application shall use broadcasting. For broadcasting in <a class="el" href="group__aps__data.html#ga2a584bc786c377e3e69b0896b0d0a55f" title="Sends data to a node in the network.">APS_DataReq()</a> parameters specify <a href="#short_addressing">the short addressing</a> as the addressing mode and assign the <code>dstAddress.shortAddress</code> field to one of broadcast addresses:</p>
<ul>
<li><em>BROADCAST_ADDR_ALL (0xFFFF)</em> <br/>
 Send the message to all nodes in the network</li>
</ul>
<ul>
<li><em>BROADCAST_ADDR_RX_ON_WHEN_IDLE (0xFFFD)</em> <br/>
 Send the message to all nodes with rxOnWhenIdle set to 1</li>
</ul>
<ul>
<li><em>BROADCAST_ADDR_ROUTERS (0xFFFC)</em> <br/>
 Send the message to all routers</li>
</ul>
<p>Other request parameters shall be configured in the same way as for a unicast message.</p>
<h3><a class="anchor" id="ack"></a>
Acknowledged data transmission</h3>
<p>While sending a unicast data message it is possible to request for acknowledgement on the application level by setting the <code>txOptions.acknowledgedTransmission</code> field of the APS data request parameters to 1: </p>
<div class="fragment"><pre class="fragment"><a class="code" href="struct_a_p_s___data_req__t.html" title="The structure for request parameters of APS_DataReq() function.">APS_DataReq_t</a> dataReq; <span class="comment">//A variable for the request parameters</span>
...
dataReq.<a class="code" href="struct_a_p_s___data_req__t.html#a329f813de89d84c93887e0a42959d02f">txOptions</a>.acknowledgedTransmission = 1;
</pre></div><p>In this cases execution of a confirmation callback with <a class="el" href="aps_common_8h.html#a1b4ff3a412400f1920d4d56e771230c8a0787d3e34ec427cb7d3107395f348538">APS_SUCCESS_STATUS</a> means that the data has been successufully delivered and the indication callback has been called on the destination endpoint. If an acknowledgement is not requested then the confirmation callback is called after the response from a node in one hop distance is received by the stack, thus calling the callback does not imply that the message has been delivered.</p>
<h3><a class="anchor" id="data_req_binding"></a>
Applying binding for data transmission</h3>
<p>To send data to all devices bound to a given cluster on the local device use <a class="el" href="group__aps__data.html#ga2a584bc786c377e3e69b0896b0d0a55f" title="Sends data to a node in the network.">APS_DataReq()</a> with the <code>dstAddrMode</code> field of the request parameters set to <a class="el" href="aps_common_8h.html#a0bc5b23d1c85adcef057f8c04dfc5365a0d86b2a778d6ff80a43cb246fe4732c2">APS_NO_ADDRESS</a>. In this case the <code>dstAddress</code> field is not used. Information about destination devices is obtained from the binding table, i.e. the message is sent to all extended addresses that occur in the binding table paired with the specified cluster ID. Consider the example:</p>
<div class="fragment"><pre class="fragment">AppMessageBuffer_t appMessageBuffer; <span class="comment">//A variable for the message buffer</span>
<a class="code" href="struct_a_p_s___data_req__t.html" title="The structure for request parameters of APS_DataReq() function.">APS_DataReq_t</a> dataReq; <span class="comment">//A variable for the request parameters</span>
<span class="comment">//A confirmation callback for APS_DataReq()</span>
<span class="keywordtype">void</span> APS_DataConf(<a class="code" href="struct_a_p_s___data_conf__t.html" title="The structure for reporting the result of APS_DataReq() function.">APS_DataConf_t</a> *confInfo)
{
  ...
}
...
dataReq.<a class="code" href="struct_a_p_s___data_req__t.html#a78008f477ee82a519794580047eafa31">profileId</a> = APP_PROFILE_ID;
dataReq.<a class="code" href="struct_a_p_s___data_req__t.html#ac816e4593f69008682cf3fa697aef65b">srcEndpoint</a> = SRC_ENDPOINT_ID;
dataReq.<a class="code" href="struct_a_p_s___data_req__t.html#acf9d887c5027cc63f2328661bfe5f532">dstAddrMode</a> = <a class="code" href="aps_common_8h.html#a0bc5b23d1c85adcef057f8c04dfc5365a0d86b2a778d6ff80a43cb246fe4732c2">APS_NO_ADDRESS</a>;
dataReq.<a class="code" href="struct_a_p_s___data_req__t.html#a48256007954e7a4e9b85ef0c166e9a93">clusterId</a> = CPU_TO_LE16(SAMPLE_CLUSTER_ID);

dataReq.<a class="code" href="struct_a_p_s___data_req__t.html#afb9d6e8ddb106b90557107a92d1408ca">radius</a> = 0x0;
<span class="comment">//Specify a callback</span>
dataReq.<a class="code" href="struct_a_p_s___data_req__t.html#a008411aa3c3ab38f4646c976b7163f3b">APS_DataConf</a> = APS_DataConf;
<span class="comment">//Configure the payload</span>
dataReq.<a class="code" href="struct_a_p_s___data_req__t.html#a196dc99b4a0bfea6ca3ad9871ff05c64">asdu</a> = appMessageBuffer.data;
dataReq.<a class="code" href="struct_a_p_s___data_req__t.html#ac3c1cc5c8134f4fe663aeefc58d98f68">asduLength</a> = <span class="keyword">sizeof</span>(appMessageBuffer.data);

<span class="comment">//Issue the request</span>
<a class="code" href="group__aps__data.html#ga2a584bc786c377e3e69b0896b0d0a55f" title="Sends data to a node in the network.">APS_DataReq</a>(&amp;dataReq);
</pre></div><p>It is assumed in the example that there are such application-defined constants as <code>SRC_ENDPOINT_ID</code>, <code>APP_PROFILE_ID</code>, and <code>SAMPLE_CLUSTER_ID</code>. Note the use of <code>CPU_TO_LE16</code> macro, which transforms a 16-bit value to a little endian value. If the value is symmetric, like 0x000 or 0xFFFF, then the macro can be safely omitted.</p>
<p>To find out how to bind to a device or to a group see <a href="#binding">Binding management</a>.</p>
<h3><a class="anchor" id="sec_data_req"></a>
Data transmission in secured networks</h3>
<p>Generally, if the standard security mode is enabled and the device has joined a secured network, then encryption of NWK payload is performed automatically by the stack. Thus sending APS data request is the same as for unsecured networks.</p>
<p>If encryption of the application payload should be used (as is standard link security) some additional steps may be needed. In this case each pair of communicating nodes in the network must have a link key associated to this pair. If the link key is unknown it can be requested from the trust center with the use of the <a class="el" href="group__aps__security.html#ga8c5b6259fe787815cd4317c41570a655" title="Request either the active network key or a new application link key.">APS_RequestKeyReq()</a> function (in this case the trust center should know the link key in order to reply). The trust center sends a message containing the link key to both the originator of the request and the destination node. Find out <a href="#request_link_key">more details</a> on requesting link key as well as source code examples.</p>
<p>To enable encryption of the application payload (with a link key), while sending a data request via the <a class="el" href="group__aps__data.html#ga2a584bc786c377e3e69b0896b0d0a55f" title="Sends data to a node in the network.">APS_DataReq()</a> function, the <code>txOptions.securityEnabledTransmission</code> field should be set to 1. If this field is not set explicitly application payload is not encrypted.</p>
<div class="fragment"><pre class="fragment"><a class="code" href="struct_a_p_s___data_req__t.html" title="The structure for request parameters of APS_DataReq() function.">APS_DataReq_t</a> dataReq; <span class="comment">//A variable in the global scope</span>
...
#ifdef _LINK_SECURITY_
  <span class="comment">//Compiled for the high security mode only</span>
  <span class="comment">//Enable encryption on the APS level</span>
  dataReq.<a class="code" href="struct_a_p_s___data_req__t.html#a329f813de89d84c93887e0a42959d02f">txOptions</a>.securityEnabledTransmission = 1;
<span class="preprocessor">#endif //_LINK_SECURITY_</span>
</pre></div><p>Another parameter, <code>txOptions.useNwkKey</code>, being set to 1 turns off the NWK encryption while forcing the APS encryption to use the network key instead of the link key. Consider the code sample:</p>
<div class="fragment"><pre class="fragment"><a class="code" href="struct_a_p_s___data_req__t.html" title="The structure for request parameters of APS_DataReq() function.">APS_DataReq_t</a> dataReq; <span class="comment">//A variable in the global scope</span>
...
<span class="comment">//Disable encryption of the application payload</span>
dataReq.<a class="code" href="struct_a_p_s___data_req__t.html#a329f813de89d84c93887e0a42959d02f">txOptions</a>.securityEnabledTransmission = 0;
<span class="comment">//Disable encryption of the NWK payload and force using the network key for </span>
<span class="comment">//encrypting the application payload, but since encryption of the application </span>
<span class="comment">//payload is disabled the frame will be sent unencrypted</span>
dataReq.<a class="code" href="struct_a_p_s___data_req__t.html#a329f813de89d84c93887e0a42959d02f">txOptions</a>.useNwkKey = 1;
...
APS_DataReq(&amp;dataReq);
</pre></div><h3><a class="anchor" id="to_all_endpoints"></a>
Sending a message to all endpoints on destination nodes</h3>
<p>To deliver message to all endpoints registered on destination nodes the <code>dstEndpoint</code> field of the request parameters shall be set to <code>0xFF</code>. The indication callback will be called for each endpoint registered on a destination node. If group addressing is used then the message will be delivered only to those endpoints that are registered with the specified group address.</p>
<h3><a class="anchor" id="radius"></a>
Limiting the radius of a data frame</h3>
<p>The <code>radius</code> field of the APS data request parameters limits the maximum distance in hops at which the destination should be located. Each message retransmission on its route to the destination decreases the radius by 1. When the radius reaches 0, the frame is dropped. Setting the <code>radius</code> field in the request parameters to 0 allows transmitting data over any distances.</p>
 <span class="to_top"><a href="#">Back to top</a></span>  <h2><a class="anchor" id="group_management"></a>
Managing groups</h2>
<p>A node can add itself to an arbitrary group with the help of the <a class="el" href="group__aps__data.html#ga64bb9bf327968a882d9c81f0cbc67f5a" title="Adds the current device to the members of a certain group.">APS_AddGroupReq()</a> function. A group is identified with a 16-bit group address, which has to be specified in the add group request parameters as well as an endpoint. When the function is called a new entry is inserted into the group table. The function can be called several times with the same group address and different endpoints. Consider a simple example, in which the device is added to a group with the address equal to <code>0x0001</code> and associated with the endpoint 1:</p>
<div class="fragment"><pre class="fragment"><a class="code" href="struct_a_p_s___add_group_req__t.html" title="Parameters of the APS_AddGroupReq() function.">APS_AddGroupReq_t</a> addGroupReq; <span class="comment">//Request parameters variable need not to be global</span>
                               <span class="comment">//since the function call is synchronous</span>
addGroupReq.<a class="code" href="struct_a_p_s___add_group_req__t.html#abd50a7137274b99417f9c1e8c5944cd0">endpoint</a> = 1;
addGroupReq.<a class="code" href="struct_a_p_s___add_group_req__t.html#a5fb0ddd11d91eae2347757518ab83f3e">groupAddress</a> = 0x0001;
<a class="code" href="group__aps__data.html#ga64bb9bf327968a882d9c81f0cbc67f5a" title="Adds the current device to the members of a certain group.">APS_AddGroupReq</a>(&amp;addGroupReq);

<span class="comment">//Check that the request is executed successfully</span>
<span class="keywordflow">if</span> (<a class="code" href="aps_common_8h.html#a1b4ff3a412400f1920d4d56e771230c8a0787d3e34ec427cb7d3107395f348538">APS_SUCCESS_STATUS</a> == addGroupReq.<a class="code" href="struct_a_p_s___add_group_req__t.html#a1526a3ca4dc96e1dc1b5a6747a696cef">confirm</a>.<a class="code" href="struct_a_p_s___add_group_conf__t.html#a2e67daedf8fc92b89a49b9dafcbf0f11">status</a>)
{
  ...
} 
<span class="comment">//Otherwise, check whether the table if full</span>
<span class="keywordflow">else</span> <span class="keywordflow">if</span> (<a class="code" href="aps_common_8h.html#a1b4ff3a412400f1920d4d56e771230c8aaab46766e6832edee99f3bb818e0e49a">APS_TABLE_FULL_STATUS</a> == addGroupReq.<a class="code" href="struct_a_p_s___add_group_req__t.html#a1526a3ca4dc96e1dc1b5a6747a696cef">confirm</a>.<a class="code" href="struct_a_p_s___add_group_conf__t.html#a2e67daedf8fc92b89a49b9dafcbf0f11">status</a>)
{
  ...
}
</pre></div><p>To remove a node from a group use the <a class="el" href="group__aps__data.html#ga1817dc1d30b3634608cbab0b14c4819c" title="Removes the current device from the members of a certain group.">APS_RemoveGroupReq()</a> function. Request parameters are configured in the same way as for the add group request. Setting the <code>endpoint</code> field to <code>0xFF</code> will cause deletion of all group table entries with the specified group address. There is also the <a class="el" href="group__aps__data.html#gabffb03739264507fe711c79c38a2cb43" title="Removes the current device from the members of all groups for which a given endpoint if registered...">APS_RemoveAllGroupsReq()</a> function, which removes the device from all groups associated with the given endpoint or from all groups at all if the <code>0xFF</code> value is provided as the endpoint ID.</p>
 <span class="to_top"><a href="#">Back to top</a></span>  <h2><a class="anchor" id="binding"></a>
Binding</h2>
<p>To bind an endpoint on the current device to a specific endpoint on a remote node the application shall know the extended address of that node. If the extended address of the remote device is unknown, but the short address is given, the extended address can be obtained with the use of <a href="zdo_usage.html#zdp_device_discovery">Device discovery</a> - by sending the IEEE address ZDP request. If the short address is also unknown to the application, it can perform a <a href="zdo_usage.html#zdp_service_discovery">Service Discovery</a> procedure to obtain short addresses of devices that support specific clusters.</p>
<p>When the extended address of a remote device is known as well as the ID of its endpoint supporting the target cluster the application should call the <a class="el" href="group__aps__data.html#ga00f4be3114dfcee6e2a6409b19adf6fb" title="Bind to a remote device or a group.">APS_BindReq()</a> function, adding a new entry to the local binding table. As an argument provide pointer to an instance of the <a class="el" href="struct_a_p_s___bind_req__t.html" title="The structure used to hold parameters for APS_BindReq()">APS_BindReq_t</a> type. A function call is done synchronously since sending frames over the air is not needed. In the request parameters specify the source and destination extended addresses and endpoints as well as the cluster to be associated with this binding link.</p>
<p>Once the binding link has been added to the binding table, the application can send data frames, specifying only the cluster and <a class="el" href="aps_common_8h.html#a0bc5b23d1c85adcef057f8c04dfc5365a0d86b2a778d6ff80a43cb246fe4732c2">APS_NO_ADDRESS</a> as the destination addressing mode. The stack will look for entries with the specified cluster in the binding table and send the frame to all devices which addresses are found in the entries.</p>
<h3><a class="anchor" id="bind_single"></a>
Binding to a single node</h3>
<p>The following example illustrates the process of binding to a single node:</p>
<div class="fragment"><pre class="fragment"><a class="code" href="struct_a_p_s___bind_req__t.html" title="The structure used to hold parameters for APS_BindReq()">APS_BindReq_t</a> bindReq; <span class="comment">//A variable for binding request parameters</span>
                          <span class="comment">//need not to be global</span>
<a class="code" href="group__cs__functions.html#ga0ea8ddc7bc41ce1c5ba556058ee1073b" title="Gets the value of the parameter specified by its ID and writes it to the provided address in memory...">CS_ReadParameter</a>(CS_UID_ID, &amp;bindReq.<a class="code" href="struct_a_p_s___bind_req__t.html#a17be8d46f30e3c26e457f270032d20b7">srcAddr</a>); <span class="comment">//Read own extended address</span>
bindReq.<a class="code" href="struct_a_p_s___bind_req__t.html#a89167da48676f4d71a8040ae59ec09c8">srcEndpoint</a> = APP_ENDPOINT; <span class="comment">//Assign to application-defined constant</span>
bindReq.<a class="code" href="struct_a_p_s___bind_req__t.html#a976cb765e974864007f0138b2cc8cd3e">clusterId</a> = APP_CLUSTER; <span class="comment">//Assign to application-defined constant</span>
bindReq.<a class="code" href="struct_a_p_s___bind_req__t.html#a8dc8309fc5e583c740a8265275ff342f">dstAddrMode</a> = <a class="code" href="aps_common_8h.html#a0bc5b23d1c85adcef057f8c04dfc5365a5c4534edda395953500e62e45f1b51de">APS_EXT_ADDRESS</a>;
bindReq.<a class="code" href="struct_a_p_s___bind_req__t.html#ab87cd53aa4c51554996700ef600e2992">dst</a>.unicast.extAddr = dstExtAddr; <span class="comment">//Assign to the extended address of the</span>
                                         <span class="comment">//destination node</span>
bindReq.<a class="code" href="struct_a_p_s___bind_req__t.html#ab87cd53aa4c51554996700ef600e2992">dst</a>.unicast.endpoint = dstEndpoint; <span class="comment">//Assign to the destination endpoint</span>
<a class="code" href="group__aps__data.html#ga00f4be3114dfcee6e2a6409b19adf6fb" title="Bind to a remote device or a group.">APS_BindReq</a>(&amp;bindReq); <span class="comment">//Synchronous call to APS</span>

<span class="comment">//Check that the request is executed successfully</span>
<span class="keywordflow">if</span> (<a class="code" href="aps_common_8h.html#a1b4ff3a412400f1920d4d56e771230c8a0787d3e34ec427cb7d3107395f348538">APS_SUCCESS_STATUS</a> == bindReq.<a class="code" href="struct_a_p_s___bind_req__t.html#abef8174603bb53c59fdb7e17d3786f3e">confirm</a>.<a class="code" href="struct_a_p_s___bind_conf__t.html#ae4ea646840de13c180116397c28251dc">status</a>)
{
  ...
} 
</pre></div><p>To obtain the extended address of the node ob which the application runs read the value of the <a class="el" href="cs_defaults_8h.html#a330d543f324150e27474f40c950333c2" title="Custome Passive ack threshold.">CS_UID</a> parameter. The cluster with the <code>APP_CLUSTER</code> ID has to be supported as an output cluster on the source endpoint and as an input cluster on the destination endpoint.</p>
<h3><a class="anchor" id="bind_group"></a>
Binding to a group</h3>
<p>It is also possible to bind an endpoint on the current device to an entire group. The following example illustrates the process of binding to a group:</p>
<div class="fragment"><pre class="fragment"><a class="code" href="struct_a_p_s___bind_req__t.html" title="The structure used to hold parameters for APS_BindReq()">APS_BindReq_t</a> bindReq; <span class="comment">//A variable for binding request parameters</span>
                      <span class="comment">//need not to be global</span>
<a class="code" href="group__cs__functions.html#ga0ea8ddc7bc41ce1c5ba556058ee1073b" title="Gets the value of the parameter specified by its ID and writes it to the provided address in memory...">CS_ReadParameter</a>(CS_UID_ID, &amp;bindReq.<a class="code" href="struct_a_p_s___bind_req__t.html#a17be8d46f30e3c26e457f270032d20b7">srcAddr</a>); <span class="comment">//Read own extended address</span>
bindReq.<a class="code" href="struct_a_p_s___bind_req__t.html#a89167da48676f4d71a8040ae59ec09c8">srcEndpoint</a> = APP_ENDPOINT; <span class="comment">//Assign to application-defined constant</span>
bindReq.<a class="code" href="struct_a_p_s___bind_req__t.html#a976cb765e974864007f0138b2cc8cd3e">clusterId</a> = APP_CLUSTER; <span class="comment">//Assign to application-defined constant</span>
bindReq.<a class="code" href="struct_a_p_s___bind_req__t.html#a8dc8309fc5e583c740a8265275ff342f">dstAddrMode</a> = <a class="code" href="aps_common_8h.html#a0bc5b23d1c85adcef057f8c04dfc5365ae7d06d84db475a76cfb47e96347c8505">APS_GROUP_ADDRESS</a>;
bindReq.<a class="code" href="struct_a_p_s___bind_req__t.html#ab87cd53aa4c51554996700ef600e2992">dst</a>.group = groupAddr; <span class="comment">//set to the address of the group (16bit value)</span>
<a class="code" href="group__aps__data.html#ga00f4be3114dfcee6e2a6409b19adf6fb" title="Bind to a remote device or a group.">APS_BindReq</a>(&amp;bindReq); <span class="comment">//Synchronous call to APS</span>
<span class="comment">//Check the execution status here</span>
...
</pre></div><p>In this case if data is sent using binding and the <code>APP_CLUSTER</code> cluster, the data is delivered to group members. Indication is raised on those endpoints only that are registered with the group address and support <code>APP_CLUSTER</code> as an input cluster.</p>
<h3><a class="anchor" id="unbind"></a>
Unbinding</h3>
<p>Unbinding from a group or a device is performed via the <a class="el" href="group__aps__data.html#gab418bf268ff652a18f4a2c0c89a18504" title="Unbind device from a group or from other device.">APS_UnbindReq()</a> function supplied with a pointer to an instance of <a class="el" href="struct_a_p_s___unbind_req__t.html" title="A type to hold parameters for APS_UnbindReq(), a typedef of the APS_BindReq_t type.">APS_UnbindReq_t</a> type, which is actually the same type as <a class="el" href="struct_a_p_s___bind_req__t.html" title="The structure used to hold parameters for APS_BindReq()">APS_BindReq_t</a>. Thus to unbind froma a group or a device you shall configure request parameters exactly the same way as for binding, for example:</p>
<div class="fragment"><pre class="fragment"><a class="code" href="struct_a_p_s___unbind_req__t.html" title="A type to hold parameters for APS_UnbindReq(), a typedef of the APS_BindReq_t type.">APS_UnbindReq_t</a> unbindReq; <span class="comment">//A variable for unbinding request parameters</span>
                        <span class="comment">//need not to be global</span>
<a class="code" href="group__cs__functions.html#ga0ea8ddc7bc41ce1c5ba556058ee1073b" title="Gets the value of the parameter specified by its ID and writes it to the provided address in memory...">CS_ReadParameter</a>(CS_UID_ID, &amp;unbindReq.srcAddr); <span class="comment">//Read own extended address</span>
unbindReq.srcEndpoint = APP_ENDPOINT; <span class="comment">//Assign to application-defined constant</span>
unbindReq.clusterId = APP_CLUSTER; <span class="comment">//Assign to application-defined constant</span>
unbindReq.dstAddrMode = <a class="code" href="aps_common_8h.html#a0bc5b23d1c85adcef057f8c04dfc5365a5c4534edda395953500e62e45f1b51de">APS_EXT_ADDRESS</a>;
unbindReq.dst.unicast.extAddr = dstExtAddr; <span class="comment">//Assign to the extended address of the</span>
                                         <span class="comment">//destination node</span>
unbindReq.dst.unicast.endpoint = dstEndpoint; <span class="comment">//Assign to the destination endpoint</span>
<a class="code" href="group__aps__data.html#gab418bf268ff652a18f4a2c0c89a18504" title="Unbind device from a group or from other device.">APS_UnbindReq</a>(&amp;unbindReq); <span class="comment">//Synchronous call to APS</span>
<span class="comment">//Check the execution status here</span>
...
</pre></div><p>Binding simplifies configuring parameters for data transferring. See the example of <a href="#data_req_binding">sending data with the help of binding</a>.</p>
<h3><a class="anchor" id="iter_binding_table"></a>
Iterating through the binding table</h3>
<p>Although Microchip Zigbee does not provide separate API for obtaining the content of the binding table, the application can accomplish this task, using the <a class="el" href="group__cs__functions.html#gabef924ef7ebd06fb5fc4d69cd32c5b81" title="Gets a pointer to the memory allocated for a specific internal structure.">CS_GetMemory()</a> function and obtaining the pointer to the binding table. An entry inside the binding table is of the <a class="el" href="struct_a_p_s___bind_req__t.html" title="The structure used to hold parameters for APS_BindReq()">APS_BindReq_t</a> type, which is the type for <a class="el" href="group__aps__data.html#ga00f4be3114dfcee6e2a6409b19adf6fb" title="Bind to a remote device or a group.">APS_BindReq()</a> as well. It is also possible to use the <a class="el" href="struct_aps_binding_entry__t.html" title="A type for a binding table entry.">ApsBindingEntry_t</a> type which is actually a typedef for <a class="el" href="struct_a_p_s___bind_req__t.html" title="The structure used to hold parameters for APS_BindReq()">APS_BindReq_t</a>. Therefore a pointer value received with <a class="el" href="group__cs__functions.html#gabef924ef7ebd06fb5fc4d69cd32c5b81" title="Gets a pointer to the memory allocated for a specific internal structure.">CS_GetMemory()</a> should be casted to <a class="el" href="struct_a_p_s___bind_req__t.html" title="The structure used to hold parameters for APS_BindReq()">APS_BindReq_t</a>; then, to iterate through the table, the user only has to increment the pointer. The user must not change the contents of the memory which is accessed with the use of <a class="el" href="group__cs__functions.html#gabef924ef7ebd06fb5fc4d69cd32c5b81" title="Gets a pointer to the memory allocated for a specific internal structure.">CS_GetMemory()</a>. For this purpose there is always an appropriate API in Microchip Zigbee. For example, in case of binding an entry is inserted into the table by <a class="el" href="group__aps__data.html#ga00f4be3114dfcee6e2a6409b19adf6fb" title="Bind to a remote device or a group.">APS_BindReq()</a> and removed by <a class="el" href="group__aps__data.html#gab418bf268ff652a18f4a2c0c89a18504" title="Unbind device from a group or from other device.">APS_UnbindReq()</a> described above. The user must also ensure that the pointer does not get out of the table's memory. For this purpose the size of the table shall be obtained and used.</p>
<p>The following example illustrates the described steps:</p>
<div class="fragment"><pre class="fragment"><span class="comment">//A variable to hold the pointer to the binding table memory</span>
<a class="code" href="struct_a_p_s___bind_req__t.html" title="The structure used to hold parameters for APS_BindReq()">APS_BindReq_t</a>* bindingEntry;
<span class="comment">//A variable to keep the binding table size</span>
uint8_t bindingTableSize;

<span class="comment">//Obtain a pointer to the binding table memory</span>
<a class="code" href="group__cs__functions.html#gabef924ef7ebd06fb5fc4d69cd32c5b81" title="Gets a pointer to the memory allocated for a specific internal structure.">CS_GetMemory</a>(CS_APS_BINDING_TABLE_ID, (<span class="keywordtype">void</span> *)&amp;bindingEntry);
<span class="comment">//Read the size of the binding table</span>
<a class="code" href="group__cs__functions.html#ga0ea8ddc7bc41ce1c5ba556058ee1073b" title="Gets the value of the parameter specified by its ID and writes it to the provided address in memory...">CS_ReadParameter</a>(CS_APS_BINDING_TABLE_SIZE_ID, (<span class="keywordtype">void</span> *)&amp;bindingTableSize);

<a class="code" href="struct_a_p_s___bind_req__t.html" title="The structure used to hold parameters for APS_BindReq()">APS_BindReq_t</a>* iter = bindingEntry;
<span class="keyword">const</span> <a class="code" href="struct_aps_binding_entry__t.html" title="A type for a binding table entry.">ApsBindingEntry_t</a> *<span class="keyword">const</span> end = iter + bindingTableSize;

<span class="comment">//Iterate through the table&#39;s content</span>
<span class="keywordflow">for</span> (; iter &lt; end; ++iter)
{
  <span class="comment">//Process required actions for each entry with the extended address</span>
  <span class="comment">//equal to dstAddressOfInterest</span>
  <span class="keywordflow">if</span> (<a class="code" href="aps_common_8h.html#a0bc5b23d1c85adcef057f8c04dfc5365a5c4534edda395953500e62e45f1b51de">APS_EXT_ADDRESS</a> == iter-&gt;<a class="code" href="struct_a_p_s___bind_req__t.html#a8dc8309fc5e583c740a8265275ff342f">dstAddrMode</a>)
    <span class="keywordflow">if</span> (dstAddressOfInterest == iter-&gt;<a class="code" href="struct_a_p_s___bind_req__t.html#ab87cd53aa4c51554996700ef600e2992">dst</a>.unicast.extAddr)
      <span class="comment">//Process an entry</span>
      ...
}
</pre></div> <span class="to_top"><a href="#">Back to top</a></span>  <h2><a class="anchor" id="high_sec_api"></a>
Using security keys API</h2>
<h3><a class="anchor" id="key_mgmt_overview"></a>
Key management API overview</h3>
<p>Security keys are used to encrypt data frames and secure device authentication in secured networks. In addition to no-security mode, when no encryption and no security keys are used, there are three modes of actual security in Microchip Zigbee networks: standard security, standard security with link keys and high security. To use a particular security mode, the application shall be compiled with the corresponding Microchip Zigbee library.</p>
<p>Note that the high security mode is not supported by publicly available BiCloud packages; Microchip Zigbee libraries with high security support are provided on demand.</p>
<p>In the network that uses standard security the only type of keys called network keys is used. A network key (the same for all nodes) is used to encrypt payload of a data frame on the NWK layer. Standard security with link keys, being an extension to standard security, offers additional level of encryption: application payload is encrypted with the help of a link key, which is specific for each pair of communicating devices. High security adds one more type of security keys called master keys, which are used to generate random link keys using the SKKE procedure.</p>
<p>The API for security keys' management is provided by the APS component and is spread in several header files. This brief overview is intended to bring together all functions related to security key management. Only the trust center can use all of this functions. Nodes different from the trust center have access to a limited number of functions.</p>
<p>Although a typical network uses a single network key for all network communications, a device in such a network can store several network keys at a time with one key being active at a time throughout the network. The trust center can switch the current active key to another key on a remote device via the APS_SwitchKey() function. Another function, APS_TransportKey(), which is mostly used by the stack, can be used by the trust center to distribute a new network key in the network.</p>
<p>Standard link security and high security provide more functions, which are described in the following list of functions are used in standard link security (for detail click a link to see function specification):</p>
<ul>
<li><a class="el" href="group__aps__security.html#ga4d97ec9bad11b340c8fa114db1d7a92c" title="Sets a link key for the device with a given extended address.">APS_SetLinkKey()</a> and <a class="el" href="group__aps__security.html#gaf6bad000710b8a34e6493005132fe288" title="Sets a master key for the device with a given extended address.">APS_SetMasterKey()</a> <br/>
 These functions set a link key and a mster key for a given device. The value is written to an internal structure called the APS key-pair set.</li>
</ul>
<ul>
<li><a class="el" href="group__aps__security.html#gaf284854b8e67a19aa3ecdab2271b0705" title="Get a pointer to the link key value by a given key handle.">APS_GetLinkKey()</a> and <a class="el" href="group__aps__security.html#ga7d48f855d7bdc744b7f3bc5e5e9d57e4" title="Get a pointer to the master key value by a given key handle.">APS_GetMasterKey()</a> <br/>
 These functions get a link key and a master key values for a given device. The value is stored the APS key-pair set.</li>
</ul>
<ul>
<li><a class="el" href="group__aps__security.html#ga3229d2abe9efd3d4e35cd4338cfaf988" title="Find the master key or the link key corresponding to a given extended address.">APS_FindKeys()</a> <br/>
 The function searches for a link key or a master key in the APS key-pair set.</li>
</ul>
<ul>
<li><a class="el" href="group__aps__security.html#ga8c5b6259fe787815cd4317c41570a655" title="Request either the active network key or a new application link key.">APS_RequestKeyReq()</a> <br/>
 The function sends a command to the trust center to provide a link key for communication with a particular device. The trust center sends the link key to both the initiator of the request and the target device.</li>
</ul>
 
<!--
  \li 
    APS_EstablishKeyReq()
	  
    The function starts a link key establishment procedure to generate a link key for a pair of devices
    on the basis of the master key. The master key must be specified by the APS_SetMasterKey()
    function on both devices.
  
-->
<h3><a class="anchor" id="set_link_key"></a>
Setting link keys</h3>
<p>Before the network start in standard link security, a device should set the trust center link key and application link keys (if required) using the <a class="el" href="group__aps__security.html#ga4d97ec9bad11b340c8fa114db1d7a92c" title="Sets a link key for the device with a given extended address.">APS_SetLinkKey()</a> function. Each device except for the trust center should specify a link key for communication with the trust center, while the trust center should specify a link key (the same as on the corresponding device) for all devices that will join the network.</p>
<p>It is reasonable to embrace the code for the standard link security mode with the conditional defines checking if <code>_LINK_SECURITY_</code> is enabled. In the following example the coordinator is to act as the trust center. Besides the coordinator, two more devices with <code>DEVICE1_EXT_ADDR</code> and <code>DEVICE1_EXT_ADDR</code> extended addresses are to join the network.</p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">#define LINK_KEY {0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa}</span>
<span class="preprocessor"></span><a class="code" href="app_framework_8h.html#aef965477e435259ad93f316e8cc286ca">DeviceType_t</a> deviceType;
<span class="comment">//deviceType is initialized somewhere in the code</span>
...
<span class="comment">//The following code is compiled for applications with</span>
<span class="comment">//high security only</span>
#ifdef _LINK_SECURITY_
  <span class="keywordflow">if</span> (deviceType != DEVICE_TYPE_COORDINATOR)
  {
    uint8_t linkKey[16] = LINK_KEY;
    <a class="code" href="mac_addr_8h.html#a5b2913b1523fd1ce0a399c4fb047cc8b" title="Extended address type declaration.">ExtAddr_t</a> extAddr = CCPU_TO_LE64(COORDINATOR_EXT_ADDR);
    <a class="code" href="group__aps__security.html#ga4d97ec9bad11b340c8fa114db1d7a92c" title="Sets a link key for the device with a given extended address.">APS_SetLinkKey</a>(&amp;extAddr, linkKey);
  }
  <span class="keywordflow">else</span>
  {
    uint8_t linkKey[16] = LINK_KEY; <span class="comment">//Link key is the same for both</span>
                                    <span class="comment">//devices</span>
    
    <span class="comment">//Extended address for the first device</span>
    <a class="code" href="mac_addr_8h.html#a5b2913b1523fd1ce0a399c4fb047cc8b" title="Extended address type declaration.">ExtAddr_t</a> extAddr = CCPU_TO_LE64(DEVICE1_EXT_ADDR);
    <a class="code" href="group__aps__security.html#ga4d97ec9bad11b340c8fa114db1d7a92c" title="Sets a link key for the device with a given extended address.">APS_SetLinkKey</a>(&amp;extAddr, linkKey);

    <span class="comment">//Extended address for the second device</span>
    <a class="code" href="mac_addr_8h.html#a5b2913b1523fd1ce0a399c4fb047cc8b" title="Extended address type declaration.">ExtAddr_t</a> extAddr1 = CCPU_TO_LE64(DEVICE2_EXT_ADDR);
    <a class="code" href="group__aps__security.html#ga4d97ec9bad11b340c8fa114db1d7a92c" title="Sets a link key for the device with a given extended address.">APS_SetLinkKey</a>(&amp;extAddr1, linkKey);
  }
<span class="preprocessor">#endif // _LINK_SECURITY_</span>
</pre></div><p><code>devicetype</code> is a variable holding the device type. The way its value is determined depends on ht eapplication entirely. The application may choose to built different firmware images for every device type or specify the device type at runtime. The <code>CCPU_TO_LE64</code> macro converts a 64-bit value to a 64-bit little endian value.</p>
<h3><a class="anchor" id="request_link_key"></a>
Request for a link key</h3>
<p>If a node does not know a link key for communication with a remote node it can send a request for it to the trust center via the <a class="el" href="group__aps__security.html#ga8c5b6259fe787815cd4317c41570a655" title="Request either the active network key or a new application link key.">APS_RequestKeyReq()</a> function. To find out whether a link key for a certain node is known, that is, is stored in the APS key-pair set, use the <a class="el" href="group__aps__security.html#ga3229d2abe9efd3d4e35cd4338cfaf988" title="Find the master key or the link key corresponding to a given extended address.">APS_FindKeys()</a> as follows:</p>
<div class="fragment"><pre class="fragment"><span class="comment">//A variable to keep the extended address of a device with which</span>
<span class="comment">//the application is going to communicate with</span>
<a class="code" href="mac_addr_8h.html#a5b2913b1523fd1ce0a399c4fb047cc8b" title="Extended address type declaration.">ExtAddr_t</a> extAddrToCommunicateWith;
...
if (!<a class="code" href="aps_crypto_keys_8h.html#a13f6a12c2990da1e8de138657abe016c">APS_KEYS_FOUND</a>(<a class="code" href="group__aps__security.html#ga3229d2abe9efd3d4e35cd4338cfaf988" title="Find the master key or the link key corresponding to a given extended address.">APS_FindKeys</a>(&amp;extAddrToCommunicateWith)))
{
  <span class="comment">//Link key is not found</span>
  ...
}
</pre></div><p>If a link key is not found in order to send data to the node the application shall request for a link key. The example illustrates parameters configuration for the <a class="el" href="group__aps__security.html#ga8c5b6259fe787815cd4317c41570a655" title="Request either the active network key or a new application link key.">APS_RequestKeyReq()</a> function.</p>
<div class="fragment"><pre class="fragment"><a class="code" href="mac_addr_8h.html#a5b2913b1523fd1ce0a399c4fb047cc8b" title="Extended address type declaration.">ExtAddr_t</a> tcAddr;
<span class="comment">//Read the trust center address and store it in a prepared variable</span>
<a class="code" href="group__cs__functions.html#ga0ea8ddc7bc41ce1c5ba556058ee1073b" title="Gets the value of the parameter specified by its ID and writes it to the provided address in memory...">CS_ReadParameter</a>(CS_APS_TRUST_CENTER_ADDRESS_ID, &amp;tcAddr);

apsRequestKeyReq.destAddress = tcAddr;
apsRequestKeyReq.keyType = APS_APP_KEY_TYPE;
apsRequestKeyReq.partnerAddress = extAddrToCommunicateWith;
apsRequestKeyReq.APS_RequestKeyConf = apsRequestKeyConf; <span class="comment">//Confirmation callback</span>
 
<a class="code" href="group__aps__security.html#ga8c5b6259fe787815cd4317c41570a655" title="Request either the active network key or a new application link key.">APS_RequestKeyReq</a>(&amp;apsRequestKeyReq);
</pre></div> 
<!--

\subsection master_key Setting a master key

A master key is used to establish the trust center link key for a device, while it is
joining the network, and application link keys for a pair of common devices. 
This is valid for high security with ::CS_ZDO_SECURITY_STATUS 
equal to 2 or 3. The trust center must be aware of master keys 
for all devices that are going to join the network, while the device may not know the
trust center master key if ::CS_ZDO_SECURITY_STATUS equals 3. In this case
the trust center master key is sent to the joining device from the trust center
in an unencrypted frame at the beginning of authentication.

A master key is set using the APS_SetMasterKey() function, which inserts an entry into 
the APS key-pair set containing a specified master key and the destination extended 
address (for the joining device it will be the trust center address, for the trust 
center - the joining device's address).

-->
 </div></div>
<hr style="border-top:1px solid #C4CFE5; margin-top:20px"/>
</body>
</html>
